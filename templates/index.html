<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrystalNexus</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="/static/js/utils.js"></script>
    <style>
        .info-icon {
            font-size: 14px;
            color: #666;
            cursor: pointer;
            margin-left: 8px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .info-icon:hover {
            opacity: 1;
        }
        
        :root {
            --main-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        /* Drop Zone Styles */
        .drop-zone {
            position: relative;
            min-height: 80px;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            background-color: #fafafa;
        }
        
        .drop-zone.drag-over {
            border-color: #3498db;
            background-color: rgba(52, 152, 219, 0.05);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }
        
        .drop-zone.drop-success {
            animation: drop-success 0.6s ease;
            border-color: #27ae60;
        }
        
        .drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(52, 152, 219, 0.1);
            border: 2px solid #3498db;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #2980b9;
            pointer-events: none;
        }
        
        .drop-instruction {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        
        .drop-message {
            font-size: 16px;
            color: #2980b9;
        }
        
        @keyframes drop-success {
            0% { 
                transform: scale(1.02); 
                background-color: rgba(52, 152, 219, 0.05); 
            }
            50% { 
                transform: scale(1.05); 
                background-color: rgba(46, 204, 113, 0.1); 
            }
            100% { 
                transform: scale(1); 
                background-color: rgba(46, 204, 113, 0.05); 
            }
        }
        
        /* File Status Styles */
        .file-status-area {
            margin-top: 10px;
        }
        
        .file-status {
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .file-status.loading {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            color: #495057;
        }
        
        .file-status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .file-status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            display: inline-block;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-details {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .error-message {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .error-suggestions {
            font-size: 12px;
            color: #856404;
        }
        
        .error-suggestions ul {
            margin: 4px 0 0 20px;
            padding-left: 0;
        }
        
        .status-icon {
            font-size: 14px;
        }
        
        .chgnet-info-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .chgnet-info-content {
            background-color: #ffffff;
            margin: 3% auto;
            padding: 40px;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            width: 85%;
            max-width: 900px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-family: var(--main-font-family);
            line-height: 1.6;
        }
        .chgnet-info-content h2 {
            text-align: left;
            margin: 0 0 20px 0;
            color: #2c2c2c;
            font-size: 22px;
            font-weight: bold;
        }
        .chgnet-info-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .chgnet-info-close:hover {
            color: black;
        }
        .chgnet-links {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e8e8e8;
        }
        .chgnet-links h4 {
            margin: 0 0 12px 0;
            color: #2c2c2c;
            font-size: 16px;
            font-weight: bold;
            font-family: var(--main-font-family);
        }
        .chgnet-links a {
            display: block;
            margin: 6px 0;
            padding: 0;
            background-color: transparent;
            color: #2980b9;
            text-decoration: underline;
            border-radius: 0px;
            font-size: 14px;
            font-family: var(--main-font-family);
        }
        .chgnet-links a:hover {
            background-color: transparent;
            color: #1c5d8b;
        }
        .chgnet-section {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e8e8e8;
        }
        .chgnet-section:last-child {
            border-bottom: none;
        }
        .chgnet-section h4 {
            margin: 0 0 14px 0;
            color: #2c2c2c;
            font-size: 18px;
            font-weight: bold;
            font-family: var(--main-font-family);
        }
        .chgnet-section h2 {
            margin: 0 0 30px 0;
            color: #1a1a1a;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid #666;
            padding-bottom: 12px;
            font-family: var(--main-font-family);
        }
        .chgnet-section p {
            margin: 0 0 12px 0;
            text-align: justify;
            color: #333;
        }
        .citation-box {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 0px;
            border: 1px solid #ddd;
            font-family: var(--main-font-family);
            font-size: 14px;
            line-height: 1.7;
            margin: 16px 0;
        }
        .citation-box p {
            margin: 0 0 8px 0;
        }
        .citation-box p:last-child {
            margin: 0;
        }
        .chgnet-info-content ul {
            padding-left: 20px;
        }
        .chgnet-info-content li {
            margin: 6px 0;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="header-title">
            <img src="/static/crystalnexus_whitelogo.png" alt="CrystalNexus Logo" class="header-logo">
            CrystalNexus
        </h1>
        <div class="header-controls">
            <a href="/static/user_guide.html" target="_blank" class="help-btn" title="CrystalNexus User Guide - How to use this application">
                üìñ User Guide
            </a>
        </div>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title">Structure Operations</div>
                <div id="structure-operations-content" class="mock-text">Element substitution and deletion controls</div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Crystal Information 
                    <button class="copy-btn" id="copy-main-crystal-info" onclick="copyMainCrystalInfo()" title="Copy: All Crystal Information" style="margin-left: 8px; display: none;">üìã</button>
                </div>
                <div id="main-crystal-info" class="mock-text">Structure details will be displayed here</div>
            </div>
        </div>

        <div class="center-panel">
            <div class="viewer-container" id="viewer-container">
                <div class="mock-text">Crystal structure will be displayed here using 3Dmol.js</div>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">
                    CHGNet Calculation 
                    <span class="info-icon" onclick="showCHGNetInfo()" title="Click for more information about CHGNet">‚ÑπÔ∏è</span>
                </div>
                <div id="chgnet-content">
                    <div class="chgnet-controls">
                        <button class="button" id="analyze-btn" disabled>üî¨ Analyze Structure</button>
                        
                        <div class="relax-settings" style="margin-top: 15px;" id="relax-settings">
                            <details style="margin-bottom: 10px;">
                                <summary style="font-size: 12px; color: #666; cursor: pointer; padding: 5px 0;">
                                    ‚öôÔ∏è Advanced Settings
                                </summary>
                                <div style="margin-top: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 4px;">
                                    <div class="setting-group">
                                        <label for="fmax-input">Force tolerance (eV/√Ö):</label>
                                        <input type="number" id="fmax-input" value="0.1" min="0.01" max="1.0" step="0.01">
                                    </div>
                                    <div class="setting-group">
                                        <label for="max-steps-input">Max steps:</label>
                                        <input type="number" id="max-steps-input" value="100" min="10" max="500" step="10">
                                    </div>
                                </div>
                            </details>
                            
                        </div>
                    </div>
                    
                    <div class="chgnet-status" id="chgnet-status" style="display: none;">
                        <div class="status-text" id="status-text">Ready</div>
                        <div class="progress-bar" id="progress-bar" style="display: none;">
                            <div class="progress-fill"></div>
                        </div>
                    </div>
                    
                    <div class="chgnet-results" id="chgnet-results" style="display: none;">
                        
                        <!-- Calculation Time Display -->
                        <div class="calculation-time" id="calculation-time" style="display: none;"></div>
                        
                        <!-- Energy Result Item -->
                        <div class="result-item" id="energy-item">
                            <div class="result-summary">
                                <span id="energy-summary">‚ö° Energy: - eV</span>
                                <button class="detail-btn" onclick="toggleDetail('energy')" id="energy-detail-btn" style="display: none;">Details ‚ñº</button>
                            </div>
                            <div class="detail-drawer" id="energy-detail" style="display: none;">
                                <div class="expandable-data" id="energy-details-table">
                                    <!-- Energy details will be populated here -->
                                </div>
                            </div>
                        </div>

                        <!-- Magnetic Properties Result Item -->
                        <div class="result-item" id="magnetic-item">
                            <div class="result-summary">
                                <span id="magnetic-summary">üß≤ Magnetic: - ¬µB total</span>
                                <button class="detail-btn" onclick="toggleDetail('magnetic')" id="magnetic-detail-btn" style="display: none;">Details ‚ñº</button>
                            </div>
                            <div class="detail-drawer" id="magnetic-detail" style="display: none;">
                                <table class="detail-table" id="magnetic-table">
                                    <!-- Magnetic details will be populated here -->
                                </table>
                            </div>
                        </div>


                        
                        <!-- Structure Status Message -->
                        <div class="status-message" id="structure-status" style="display: none;">
                            ‚ö†Ô∏è Structure modified - Analysis required
                        </div>

                        <!-- Detailed Analysis Button -->
                        <button class="detail-analysis-btn" id="detailAnalysisBtn" onclick="openAnalysisModal()" style="display: none;">
                            üìä Detailed Analysis
                        </button>
                        
                        <!-- Download Analysis Button -->
                        <button class="detail-analysis-btn" id="downloadAnalysisBtn" onclick="downloadAnalysisData()" style="display: none;">
                            üíæ Download Analysis
                        </button>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Window -->
    <div id="cifModal" class="modal">
        <div class="modal-content">
            <div class="cif-modal-header" style="grid-area: header;">
                Select CIF File
            </div>
            
            <div class="modal-main" style="grid-area: main;">
                <div class="file-selection">
                    <div class="radio-option selected" data-value="sample">
                        <input type="radio" name="file-source" value="sample" checked id="radio-sample">
                        <label for="radio-sample">Use sample CIF file</label>
                    </div>
                    <div class="file-input-section">
                        <select id="sampleFileSelect">
                            <option value="">Loading sample files...</option>
                        </select>
                    </div>
                </div>
                
                <div class="file-selection">
                    <div class="radio-option" data-value="upload">
                        <input type="radio" name="file-source" value="upload" id="radio-upload">
                        <label for="radio-upload">Upload your own CIF file</label>
                    </div>
                    <div class="file-input-section drop-zone" id="uploadDropZone">
                        <div class="drop-zone-content">
                            <p class="drop-instruction">üìÅ Drop CIF file here or</p>
                            <div class="custom-file-input-wrapper">
                                <input type="file" id="uploadFile" accept=".cif" disabled style="display: none;">
                                <button type="button" id="customFileButton" class="custom-file-button" disabled>
                                    üìÇ Select CIF File
                                </button>
                            </div>
                        </div>
                        <div class="drop-overlay" id="dropOverlay" style="display: none;">
                            <div class="drop-message">üìé Drop file to upload</div>
                        </div>
                        <div id="fileStatusArea" class="file-status-area"></div>
                    </div>
                </div>
                
                <!-- Settings Section -->
                <div id="settingsSection" class="settings-section hidden">
                    <div class="settings-header">
                        <span>‚öôÔ∏è Settings</span>
                        <button class="advanced-settings-btn" id="advancedSettingsBtn">
                            Advanced ‚ñº
                        </button>
                    </div>
                    
                    <div id="supercellSection" class="supercell-main">
                        <div class="supercell-title">Supercell Configuration</div>
                        <div class="supercell-inputs-inline-labeled">
                            <div class="supercell-axis-group">
                                <label>a:</label>
                                <input type="number" id="supercell-a" value="1" min="1" max="10">
                            </div>
                            <div class="supercell-axis-group">
                                <label>b:</label>
                                <input type="number" id="supercell-b" value="1" min="1" max="10">
                            </div>
                            <div class="supercell-axis-group">
                                <label>c:</label>
                                <input type="number" id="supercell-c" value="1" min="1" max="10">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Advanced Settings Panel -->
                    <div id="advancedSettingsPanel" class="advanced-settings-panel" style="display: none;">
                        <div class="advanced-setting-item">
                            <label for="modal-max-atoms-limit">Max total atoms:</label>
                            <input type="number" id="modal-max-atoms-limit" value="200" min="50" max="2000" step="10">
                        </div>
                        <div class="advanced-setting-note">
                            Higher limits may slow down analysis and visualization
                        </div>
                    </div>
                </div>
                
            </div>
            
            <div class="modal-sidebar" style="grid-area: sidebar;">
                <div id="crystalInfo" class="crystal-info-sidebar hidden">
                    <div class="crystal-info-header">
                        <strong style="font-size: 13px;">Crystal Information</strong>
                        <button class="copy-btn" id="copy-crystal-info" onclick="copyAllCrystalInfo()" title="Copy: All Crystal Information">üìã</button>
                    </div>
                    <div id="infoContent" class="crystal-info-content"></div>
                </div>
            </div>
            
            <div class="modal-confirm" style="grid-area: confirm;">
                <button id="confirmButton" class="button" disabled>Confirm</button>
            </div>
        </div>
    </div>

    <script>
        window.currentCrystalData = null;
        let supercellData = null;
        let chgnetElements = [];
        
        // Immutable original data (never changes after modal closes) - GLOBAL for robust system
        window.originalSupercellData = null;
        window.originalLabels = [];
        
        // Current working data (modified by operations) - GLOBAL for robust system
        window.currentStructureData = null;
        window.currentLabels = [];
        
        // Atomic operations history for complete 3D visualization
        window.atomicOperations = [];
        
        // Generate session ID
        window.sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        console.log('Session ID:', window.sessionId);

        // Unified status display system
        window.displayStatus = {
            energy: { 
                calculated: false, 
                value: null, 
                status: 'ready',
                hasData: false 
            },
            magnetic: { 
                calculated: false, 
                value: null, 
                status: 'ready',
                hasData: false 
            }
        };

        // Status messages
        const STATUS_MESSAGES = {
            ready: 'Ready to calculate',
            calculating: 'Calculating...',
            notCalculated: 'Not calculated',
            error: 'Calculation error'
        };

        // Update display based on current status
        function updateStatusDisplay(type, status, value = null, hasData = false) {
            window.displayStatus[type] = { 
                calculated: status === 'calculated', 
                value: value, 
                status: status,
                hasData: hasData 
            };
            refreshDisplay(type);
        }

        // Refresh the display for a specific type
        function refreshDisplay(type) {
            const statusObj = window.displayStatus[type];
            const summaryElement = document.getElementById(`${type}-summary`);
            const detailBtn = document.getElementById(`${type}-detail-btn`);
            const item = document.getElementById(`${type}-item`);
            
            if (!summaryElement) return;
            
            const icon = type === 'energy' ? '‚ö°' : 'üß≤';
            const unit = type === 'energy' ? 'eV' : '¬µB total';
            
            if (statusObj.calculated && statusObj.value !== null) {
                // Show calculated value with copy button
                const copyBtnId = `copy-total-${type}`;
                const copyFunction = type === 'energy' ? 'copyTotalEnergy()' : 'copyTotalMagnetic()';
                const title = type === 'energy' ? 'Copy: Total Energy' : 'Copy: Total Magnetic Moment';
                
                if (type === 'energy') {
                    const valueClass = statusObj.value < 0 ? 'energy-negative' : 'energy-positive';
                    summaryElement.innerHTML = `${icon} Energy: <span class="${valueClass}">${statusObj.value.toFixed(2)} eV</span><button class="copy-btn" id="${copyBtnId}" onclick="${copyFunction}" title="${title}">üìã</button>`;
                } else {
                    summaryElement.innerHTML = `${icon} Magnetic: <span class="magnetic-moment">${statusObj.value.toFixed(3)} ¬µB total</span><button class="copy-btn" id="${copyBtnId}" onclick="${copyFunction}" title="${title}">üìã</button>`;
                }
                
                if (detailBtn) detailBtn.style.display = 'inline-block';
                if (item && type === 'magnetic') item.style.display = 'block';
            } else {
                // Show status message
                let message;
                if (statusObj.status === 'ready') {
                    message = STATUS_MESSAGES.ready;
                } else if (statusObj.status === 'calculating') {
                    message = STATUS_MESSAGES.calculating;
                } else if (statusObj.status === 'notCalculated') {
                    message = STATUS_MESSAGES.notCalculated;
                } else {
                    message = STATUS_MESSAGES.error;
                }
                
                summaryElement.textContent = `${icon} ${type === 'energy' ? 'Energy' : 'Magnetic'}: ${message}`;
                if (detailBtn) detailBtn.style.display = 'none';
                // Always show magnetic item to display status messages
                if (item && type === 'magnetic') item.style.display = 'block';
            }
        }

        // Initialize displays
        function initializeDisplays() {
            // Wait for DOM to be fully loaded before initializing
            setTimeout(() => {
                try {
                    updateStatusDisplay('energy', 'notCalculated');
                    updateStatusDisplay('magnetic', 'notCalculated');
                } catch (error) {
                    console.warn('Display initialization delayed:', error);
                    // Retry after another short delay
                    setTimeout(() => {
                        try {
                            updateStatusDisplay('energy', 'notCalculated');
                            updateStatusDisplay('magnetic', 'notCalculated');
                        } catch (retryError) {
                            console.error('Failed to initialize displays:', retryError);
                        }
                    }, 500);
                }
            }, 100);
        }

        // Update session with atomic operations
        async function updateSessionWithOperations() {
            try {
                const response = await fetch('/api/apply-atomic-operations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: window.sessionId,
                        operations: window.atomicOperations
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úÖ Session updated with operations:', result);
                    
                    // Update status to ready for calculation when structure changes
                    updateStatusDisplay('energy', 'ready');
                    updateStatusDisplay('magnetic', 'ready');
                } else {
                    console.error('‚ùå Failed to update session with operations');
                }
            } catch (error) {
                console.error('‚ùå Error updating session:', error);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadSampleFiles();
            loadCHGnetElements();
            setupEventListeners();
            setupCHGNetEventListeners();
            setupDropZoneEventListeners();
            
            // Initialize unified display system
            initializeDisplays();
        });

        function setupEventListeners() {
            // Radio option visual feedback
            document.querySelectorAll('.radio-option').forEach(option => {
                option.addEventListener('click', function() {
                    const radio = this.querySelector('input[type="radio"]');
                    radio.checked = true;
                    
                    // Update visual state
                    document.querySelectorAll('.radio-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    // Trigger change event
                    radio.dispatchEvent(new Event('change'));
                });
            });

            // File source radio buttons
            document.querySelectorAll('input[name="file-source"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    const uploadFile = document.getElementById('uploadFile');
                    const customFileButton = document.getElementById('customFileButton');
                    const sampleSelect = document.getElementById('sampleFileSelect');
                    
                    if (this.value === 'upload') {
                        uploadFile.disabled = false;
                        customFileButton.disabled = false;
                        sampleSelect.disabled = true;
                    } else {
                        uploadFile.disabled = true;
                        customFileButton.disabled = true;
                        sampleSelect.disabled = false;
                    }
                    
                    resetAnalysis();
                });
            });

            // Sample file selection
            document.getElementById('sampleFileSelect').addEventListener('change', function() {
                if (this.value) {
                    analyzeSampleFile(this.value);
                } else {
                    resetAnalysis();
                }
            });

            // File upload
            document.getElementById('uploadFile').addEventListener('change', function() {
                if (this.files.length > 0) {
                    analyzeUploadedFile(this.files[0]);
                } else {
                    resetAnalysis();
                }
            });

            // Custom file button click handler
            document.getElementById('customFileButton').addEventListener('click', function() {
                document.getElementById('uploadFile').click();
            });

            // Confirm button
            document.getElementById('confirmButton').addEventListener('click', function() {
                if (window.currentCrystalData) {
                    createSupercell();
                }
            });

            // Advanced Settings toggle
            const advancedSettingsBtn = document.getElementById('advancedSettingsBtn');
            const advancedSettingsPanel = document.getElementById('advancedSettingsPanel');
            
            if (advancedSettingsBtn && advancedSettingsPanel) {
                advancedSettingsBtn.addEventListener('click', function() {
                    if (advancedSettingsPanel.style.display === 'none') {
                        advancedSettingsPanel.style.display = 'block';
                        this.innerHTML = 'Advanced ‚ñ≤';
                    } else {
                        advancedSettingsPanel.style.display = 'none';
                        this.innerHTML = 'Advanced ‚ñº';
                    }
                });
            }
        }

        async function loadSampleFiles() {
            try {
                const response = await fetch('/api/sample-cif-files');
                const data = await response.json();
                
                const select = document.getElementById('sampleFileSelect');
                select.innerHTML = '<option value="">Select a sample file...</option>';
                
                data.files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.textContent = file;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading sample files:', error);
                document.getElementById('sampleFileSelect').innerHTML = '<option value="">Error loading files</option>';
            }
        }

        async function analyzeSampleFile(filename) {
            try {
                const response = await fetch('/api/analyze-cif-sample', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                if (!response.ok) {
                    // Try to get detailed error message from response
                    let errorMessage = 'An error occurred while analyzing the file.';
                    try {
                        const errorText = await response.text();
                        console.log('Error response text:', errorText);
                        const errorData = JSON.parse(errorText);
                        if (errorData.detail) {
                            // Use server's detailed error message (user-friendly)
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        console.log('Failed to parse error response:', e);
                        // If we can't parse JSON, provide generic user-friendly message
                        if (response.status === 400) {
                            errorMessage = 'Invalid file format or structure data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                displayCrystalInfo(data);
            } catch (error) {
                console.error('Error analyzing sample file:', error);
                alert(`Error analyzing CIF file: ${error.message}`);
            }
        }

        async function analyzeUploadedFile(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('/api/analyze-cif-upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    // Try to get detailed error message from response
                    let errorMessage = 'An error occurred while analyzing the file.';
                    try {
                        const errorText = await response.text();
                        console.log('Error response text:', errorText);
                        const errorData = JSON.parse(errorText);
                        if (errorData.detail) {
                            // Use server's detailed error message (user-friendly)
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        console.log('Failed to parse error response:', e);
                        // If we can't parse JSON, provide generic user-friendly message
                        if (response.status === 400) {
                            errorMessage = 'Invalid file format or structure data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                displayCrystalInfo(data);
            } catch (error) {
                console.error('Error analyzing uploaded file:', error);
                alert(`Error analyzing CIF file: ${error.message}`);
            }
        }

        function displayCrystalInfo(data) {
            window.currentCrystalData = data;
            
            const infoContent = document.getElementById('infoContent');
            // Display information in the same order as ZrO2test.py
            infoContent.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Basic Structure Information:</div>
                    <div><strong>Formula:</strong> ${data.formula}<button class="copy-btn" id="copy-formula" onclick="copyFormula('copy-formula')" title="Copy: Formula">üìã</button></div>
                    <div><strong>Number of atoms:</strong> ${data.num_atoms}</div>
                    <div><strong>Density:</strong> ${data.density.toFixed(4)} g/cm¬≥</div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Lattice Parameters:</div>
                    <div style="margin-left: 10px;">
                        a = ${data.lattice_parameters.a.toFixed(5)} √Ö<br>
                        b = ${data.lattice_parameters.b.toFixed(5)} √Ö<br>
                        c = ${data.lattice_parameters.c.toFixed(5)} √Ö<br>
                        Œ± = ${data.lattice_parameters.alpha.toFixed(5)}¬∞<br>
                        Œ≤ = ${data.lattice_parameters.beta.toFixed(5)}¬∞<br>
                        Œ≥ = ${data.lattice_parameters.gamma.toFixed(5)}¬∞<br>
                        Volume = ${data.volume.toFixed(5)} ≈≤
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Symmetry Information:</div>
                    <div><strong>International notation:</strong> ${data.space_group}</div>
                    <div><strong>Space group number:</strong> ${data.space_group_number}</div>
                    <div><strong>Point group:</strong> ${data.point_group}</div>
                    <div><strong>Crystal system:</strong> ${data.crystal_system}</div>
                </div>
            `;
            
            // Show crystal info only if valid data exists
            showCrystalInfoConditionally(data);
            document.getElementById('settingsSection').classList.remove('hidden');
            document.getElementById('confirmButton').disabled = false;
            
            // Setup expand/collapse functionality
            setupCrystalInfoToggle();
        }
        
        function showCrystalInfoConditionally(data) {
            const crystalInfoElement = document.getElementById('crystalInfo');
            
            if (data && hasValidCrystalData(data)) {
                crystalInfoElement.classList.remove('hidden');
                crystalInfoElement.classList.add('summary'); // Start in collapsed state
                crystalInfoElement.style.display = 'block';
            } else {
                hideCrystalInfoCompletely();
            }
        }
        
        function hasValidCrystalData(data) {
            return data && (data.formula || data.space_group || data.lattice_parameters || 
                   data.crystal_system || data.volume || data.density);
        }
        
        function hideCrystalInfoCompletely() {
            const crystalInfoElement = document.getElementById('crystalInfo');
            crystalInfoElement.classList.add('hidden');
            crystalInfoElement.style.display = 'none';
        }
        
        function showCrystalInfoElement() {
            const crystalInfoElement = document.getElementById('crystalInfo');
            crystalInfoElement.classList.remove('hidden');
            crystalInfoElement.style.display = 'block';
        }
        
        // Drag and Drop functionality
        function setupDropZoneEventListeners() {
            const dropZone = document.getElementById('uploadDropZone');
            const fileInput = document.getElementById('uploadFile');
            const dropOverlay = document.getElementById('dropOverlay');
            
            if (!dropZone || !fileInput || !dropOverlay) return;
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            // Highlight drop zone when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, handleDragEnter, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, handleDragLeave, false);
            });
            
            // Handle dropped files
            dropZone.addEventListener('drop', handleFileDrop, false);
        }
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleDragEnter(e) {
            const dropZone = document.getElementById('uploadDropZone');
            const dropOverlay = document.getElementById('dropOverlay');
            const uploadRadio = document.getElementById('radio-upload');
            
            if (uploadRadio.checked) {
                dropZone.classList.add('drag-over');
                dropOverlay.style.display = 'flex';
            }
        }
        
        function handleDragLeave(e) {
            const dropZone = document.getElementById('uploadDropZone');
            const dropOverlay = document.getElementById('dropOverlay');
            
            // Check if we're leaving the drop zone area completely
            if (!dropZone.contains(e.relatedTarget)) {
                dropZone.classList.remove('drag-over');
                dropOverlay.style.display = 'none';
            }
        }
        
        function handleFileDrop(e) {
            const dropZone = document.getElementById('uploadDropZone');
            const dropOverlay = document.getElementById('dropOverlay');
            const fileInput = document.getElementById('uploadFile');
            const uploadRadio = document.getElementById('radio-upload');
            
            dropZone.classList.remove('drag-over');
            dropOverlay.style.display = 'none';
            
            const files = e.dataTransfer.files;
            
            if (files.length > 0) {
                const file = files[0];
                
                // Auto-select upload radio button
                uploadRadio.checked = true;
                fileInput.disabled = false;
                
                // Update file input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;
                
                // Show drop success animation
                dropZone.classList.add('drop-success');
                setTimeout(() => {
                    dropZone.classList.remove('drop-success');
                }, 600);
                
                // Process the file
                handleFileSelection(file);
                
                // Show file status
                showFileLoadingStatus();
            }
        }
        
        function handleFileSelection(file) {
            if (file) {
                processCIFFileEnhanced(file);
            } else {
                showFileLoadError('No file selected');
            }
        }
        
        function processCIFFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    // Process the CIF file through existing upload logic
                    fetch('/api/upload-cif', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showFileLoadSuccess(file.name);
                            // Continue with existing processing logic
                            window.currentFilename = file.name;
                            displayCrystalInfo(data);
                        } else {
                            showFileLoadError(data.message || 'Failed to process CIF file');
                        }
                    })
                    .catch(error => {
                        showFileLoadError('Network error: ' + error.message);
                    });
                } catch (error) {
                    showFileLoadError('Error reading file: ' + error.message);
                }
            };
            
            reader.onerror = function() {
                showFileLoadError('Error reading file');
            };
            
            reader.readAsText(file);
        }
        
        // Visual Feedback Functions
        function showFileLoadingStatus() {
            const statusArea = document.getElementById('fileStatusArea');
            const statusHTML = `
                <div class="file-status loading">
                    <div class="loading-spinner"></div>
                    <span>Reading CIF file...</span>
                </div>
            `;
            statusArea.innerHTML = statusHTML;
        }
        
        function showFileLoadSuccess(filename) {
            const statusArea = document.getElementById('fileStatusArea');
            const statusHTML = `
                <div class="file-status success">
                    <span class="status-icon">‚úÖ</span>
                    <span>Successfully loaded: ${filename}</span>
                </div>
            `;
            statusArea.innerHTML = statusHTML;
            
            // Auto-clear success message after 3 seconds
            setTimeout(() => {
                clearFileStatus();
            }, 3000);
        }
        
        function showFileLoadError(message) {
            const statusArea = document.getElementById('fileStatusArea');
            const statusHTML = `
                <div class="file-status error">
                    <span class="status-icon">‚ùå</span>
                    <span>Error: ${message}</span>
                </div>
            `;
            statusArea.innerHTML = statusHTML;
        }
        
        function clearFileStatus() {
            const statusArea = document.getElementById('fileStatusArea');
            if (statusArea) {
                statusArea.innerHTML = '';
            }
        }
        
        // Enhanced Error Handling
        function handleFileError(error, context = {}) {
            let errorMessage = 'Unknown error occurred';
            let suggestions = [];
            
            switch(error.type) {
                case 'FILE_TOO_LARGE':
                    errorMessage = `File is too large (${error.size}MB). Maximum size is 50MB.`;
                    suggestions = ['Try a smaller CIF file', 'Compress the file if possible'];
                    break;
                    
                case 'FILE_READ_ERROR':
                    errorMessage = 'Could not read the file. The file may be corrupted.';
                    suggestions = ['Check if the file is accessible', 'Try uploading again'];
                    break;
                    
                case 'NETWORK_ERROR':
                    errorMessage = 'Network error occurred during upload.';
                    suggestions = ['Check your internet connection', 'Try again in a moment'];
                    break;
                    
                case 'SERVER_ERROR':
                    errorMessage = 'Server error occurred while processing the file.';
                    suggestions = ['Try again later', 'Contact system administrator if problem persists'];
                    break;
                    
                case 'INVALID_FORMAT':
                    errorMessage = 'Invalid CIF file format.';
                    suggestions = ['Ensure the file is a valid CIF format', 'Check file contents in text editor'];
                    break;
                    
                default:
                    errorMessage = error.message || 'An unexpected error occurred';
                    suggestions = ['Try uploading the file again'];
            }
            
            showDetailedErrorMessage(errorMessage, suggestions);
        }
        
        function showDetailedErrorMessage(message, suggestions) {
            const statusArea = document.getElementById('fileStatusArea');
            const suggestionsHTML = suggestions.map(s => `<li>${s}</li>`).join('');
            
            const errorHTML = `
                <div class="error-details">
                    <div class="error-message">
                        <span class="status-icon">‚ö†Ô∏è</span>
                        ${message}
                    </div>
                    <div class="error-suggestions">
                        <strong>Try these solutions:</strong>
                        <ul>${suggestionsHTML}</ul>
                    </div>
                </div>
            `;
            
            statusArea.innerHTML = errorHTML;
        }
        
        // Enhanced file processing with better error handling
        function processCIFFileEnhanced(file) {
            // Basic file validation
            if (file.size > 50 * 1024 * 1024) {
                handleFileError({
                    type: 'FILE_TOO_LARGE',
                    size: (file.size / 1024 / 1024).toFixed(1)
                });
                return;
            }
            
            if (file.size === 0) {
                handleFileError({
                    type: 'FILE_READ_ERROR',
                    message: 'File appears to be empty'
                });
                return;
            }
            
            if (!file.name.toLowerCase().endsWith('.cif')) {
                handleFileError({
                    type: 'INVALID_FORMAT',
                    message: 'File must have .cif extension'
                });
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    fetch('/api/upload-cif', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            showFileLoadSuccess(file.name);
                            window.currentFilename = file.name;
                            displayCrystalInfo(data);
                        } else {
                            handleFileError({
                                type: 'SERVER_ERROR',
                                message: data.message || 'Failed to process CIF file'
                            });
                        }
                    })
                    .catch(error => {
                        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                            handleFileError({
                                type: 'NETWORK_ERROR',
                                message: 'Cannot connect to server'
                            });
                        } else {
                            handleFileError({
                                type: 'SERVER_ERROR',
                                message: error.message
                            });
                        }
                    });
                } catch (error) {
                    handleFileError({
                        type: 'FILE_READ_ERROR',
                        message: error.message
                    });
                }
            };
            
            reader.onerror = function() {
                handleFileError({
                    type: 'FILE_READ_ERROR',
                    message: 'Failed to read file'
                });
            };
            
            reader.readAsText(file);
        }

        function setupCHGNetEventListeners() {
            const analyzeBtn = document.getElementById('analyze-btn');
            
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', async () => {
                    if (supercellData && window.currentFilename) {
                        await runCHGNetAnalysis();
                    }
                });
            }
        }

        function enableCHGNetButtons() {
            const analyzeBtn = document.getElementById('analyze-btn');
            
            if (analyzeBtn) {
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'üî¨ Analyze Structure';
                analyzeBtn.classList.remove('button-processing');
            }
            
            // Set status to ready for calculation
            updateStatusDisplay('energy', 'ready');
            updateStatusDisplay('magnetic', 'ready');
        }

        function setCHGNetButtonState(state, text) {
            const analyzeBtn = document.getElementById('analyze-btn');
            if (!analyzeBtn) return;

            switch(state) {
                case 'processing':
                    analyzeBtn.disabled = true;
                    analyzeBtn.classList.add('button-processing');
                    analyzeBtn.textContent = text || '‚è≥ Processing...';
                    break;
                case 'relaxing':
                    analyzeBtn.disabled = true;
                    analyzeBtn.classList.add('button-processing');
                    analyzeBtn.textContent = 'üîÑ Structure Relaxation...';
                    break;
                case 'calculating_structure':
                    analyzeBtn.disabled = true;
                    analyzeBtn.classList.add('button-processing');
                    analyzeBtn.textContent = '‚öõÔ∏è Crystal Structure Calculation...';
                    break;
                case 'calculating_properties':
                    analyzeBtn.disabled = true;
                    analyzeBtn.classList.add('button-processing');
                    analyzeBtn.textContent = 'üìä Properties Calculation...';
                    break;
                case 'complete':
                    analyzeBtn.disabled = false;
                    analyzeBtn.classList.remove('button-processing');
                    analyzeBtn.textContent = 'üî¨ Analyze Structure';
                    break;
                default:
                    analyzeBtn.disabled = false;
                    analyzeBtn.classList.remove('button-processing');
                    analyzeBtn.textContent = 'üî¨ Analyze Structure';
            }
        }

        function showCHGNetStatus(message, showProgress = false) {
            const statusDiv = document.getElementById('chgnet-status');
            const statusText = document.getElementById('status-text');
            const progressBar = document.getElementById('progress-bar');
            
            statusDiv.style.display = 'block';
            statusText.textContent = message;
            
            if (showProgress) {
                progressBar.style.display = 'block';
            } else {
                progressBar.style.display = 'none';
            }
        }

        function hideCHGNetStatus() {
            const statusDiv = document.getElementById('chgnet-status');
            statusDiv.style.display = 'none';
        }

        function toggleDetail(section) {
            const detailDiv = document.getElementById(section + '-detail');
            const button = event.target;
            
            if (detailDiv.style.display === 'none') {
                detailDiv.style.display = 'block';
                button.innerHTML = 'Details ‚ñ≤';
            } else {
                detailDiv.style.display = 'none';
                button.innerHTML = 'Details ‚ñº';
            }
        }

        function displayCalculationTime(executionTime, steps) {
            const timeDiv = document.getElementById('calculation-time');
            if (timeDiv) {
                let text = `Calculation completed in ${executionTime}s`;
                if (steps !== undefined && steps !== null) {
                    text += ` (${steps} steps)`;
                }
                timeDiv.textContent = text;
                timeDiv.style.display = 'block';
            }
        }

        function displayCHGNetResults(data, isRelaxation = false) {
            const resultsDiv = document.getElementById('chgnet-results');
            resultsDiv.style.display = 'block';
            
            const initialPred = data.initial_prediction;
            const finalPred = isRelaxation ? data.final_prediction : data.prediction;
            const prediction = finalPred || initialPred;
            
            if (!prediction) {
                console.warn('No prediction data available');
                return;
            }
            
            // Display Energy Information
            displayEnergyResults(initialPred, finalPred, isRelaxation);
            
            // Display Magnetic Properties
            displayMagneticResults(prediction);
            
            // Site Energies are now displayed in Energy details
            
            // Store data for analysis modal
            if (isRelaxation) {
                console.log('=== Setting currentAnalysisData ===');
                console.log('isRelaxation:', isRelaxation);
                console.log('Data being stored:', data);
                window.currentAnalysisData = data;
                console.log('currentAnalysisData set to:', window.currentAnalysisData);
                document.getElementById('detailAnalysisBtn').style.display = 'block';
                document.getElementById('downloadAnalysisBtn').style.display = 'block';
                console.log('Detail analysis button displayed');
            } else {
                console.log('Not a relaxation, skipping analysis data storage');
            }
        }
        
        function displayEnergyResults(initialPred, finalPred, isRelaxation) {
            const energySummary = document.getElementById('energy-summary');
            const energyDetailBtn = document.getElementById('energy-detail-btn');
            const energyDetailsTable = document.getElementById('energy-details-table');
            
            if (finalPred && finalPred.energy_eV_per_atom !== undefined) {
                const energyPerAtom = finalPred.energy_eV_per_atom;
                
                // Calculate number of atoms and total energy
                let numAtoms = 1; // default
                if (finalPred.forces_eV_per_A) {
                    numAtoms = finalPred.forces_eV_per_A.length;
                }
                // Use total_energy_eV from backend if available, otherwise calculate
                const totalEnergy = finalPred.total_energy_eV !== undefined ? finalPred.total_energy_eV : energyPerAtom * numAtoms;
                
                // Update status display system
                updateStatusDisplay('energy', 'calculated', totalEnergy, true);
                
                // Prepare Energy details table
                let detailsHTML = '';
                
                // Add basic energy information
                detailsHTML += '<table class="detail-table">';
                detailsHTML += '<tr><th>Energy Details</th><th><button class="copy-btn" onclick="copyAllEnergyData()" title="Copy All Energy Data">üìã Copy All</button></th></tr>';
                detailsHTML += `<tr><td><strong>Energy per atom:</strong></td><td>${energyPerAtom.toFixed(6)} eV/atom</td></tr>`;
                detailsHTML += `<tr><td><strong>Number of atoms:</strong></td><td>${numAtoms} atoms</td></tr>`;
                detailsHTML += `<tr><td><strong>Total energy:</strong></td><td>${totalEnergy.toFixed(6)} eV</td></tr>`;
                detailsHTML += '</table><br>';
                
                // Add Site Energies if available
                if (finalPred.site_energies_eV) {
                    const siteEnergies = finalPred.site_energies_eV;
                    // Store site energies for copy functionality
                    window.currentSiteEnergies = siteEnergies;
                    
                    detailsHTML += '<table class="detail-table">';
                    detailsHTML += '<tr><th colspan="2">Site Energies</th></tr>';
                    
                    siteEnergies.forEach((energy, i) => {
                        // Use current labels to reflect any element substitutions
                        const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Site ${i+1}`;
                        detailsHTML += `<tr><td>${atomLabel}:</td><td class="site-energy">${energy.toFixed(6)} eV</td></tr>`;
                    });
                    
                    // Add verification
                    const siteSum = siteEnergies.reduce((sum, e) => sum + e, 0);
                    detailsHTML += `<tr><td style="padding-top: 10px;"><em>Sum of site energies:</em></td><td style="padding-top: 10px;"><em>${siteSum.toFixed(6)} eV</em></td></tr>`;
                    detailsHTML += '</table>';
                } else {
                    detailsHTML = '<p>Site energies not available for this calculation.</p>';
                }
                
                energyDetailsTable.innerHTML = detailsHTML;
                
                // Store detailed energy data for Detailed Analysis modal
                if (!window.energyAnalysisData) window.energyAnalysisData = {};
                window.energyAnalysisData = {
                    final: {
                        totalEnergy: totalEnergy,
                        energyPerAtom: energyPerAtom,
                        numAtoms: numAtoms
                    }
                };
                console.log('Energy analysis data set:', window.energyAnalysisData);
                
                // Add initial data if available (for relaxation)
                if (isRelaxation && initialPred && initialPred.energy_eV_per_atom !== undefined) {
                    const initialEnergyPerAtom = initialPred.energy_eV_per_atom;
                    const initialTotalEnergy = initialPred.total_energy_eV !== undefined ? initialPred.total_energy_eV : initialEnergyPerAtom * numAtoms;
                    
                    window.energyAnalysisData.initial = {
                        totalEnergy: initialTotalEnergy,
                        energyPerAtom: initialEnergyPerAtom,
                        numAtoms: numAtoms
                    };
                    
                    window.energyAnalysisData.changes = {
                        totalEnergyChange: totalEnergy - initialTotalEnergy,
                        energyChangePerAtom: energyPerAtom - initialEnergyPerAtom
                    };
                }
            } else {
                updateStatusDisplay('energy', 'error');
                window.energyAnalysisData = null;
            }
        }
        
        function resetPhysicalProperties() {
            // Reset using unified status display system
            updateStatusDisplay('energy', 'ready');
            updateStatusDisplay('magnetic', 'ready');
            
            // Close energy details drawer if open
            const energyDetail = document.getElementById('energy-detail');
            if (energyDetail) {
                energyDetail.style.display = 'none';
            }
            
            // Close magnetic details drawer if open  
            const magneticDetail = document.getElementById('magnetic-detail');
            if (magneticDetail) {
                magneticDetail.style.display = 'none';
            }
            
            // Clear detail tables content
            const energyDetailsTable = document.getElementById('energy-details-table');
            if (energyDetailsTable) {
                energyDetailsTable.innerHTML = '';
            }
            
            const magneticTable = document.getElementById('magnetic-table');
            if (magneticTable) {
                magneticTable.innerHTML = '';
            }
            
            // Reset detail buttons text
            const energyDetailBtn = document.getElementById('energy-detail-btn');
            if (energyDetailBtn) {
                energyDetailBtn.innerHTML = 'Details ‚ñº';
            }
            
            const magneticDetailBtn = document.getElementById('magnetic-detail-btn');
            if (magneticDetailBtn) {
                magneticDetailBtn.innerHTML = 'Details ‚ñº';
            }
            
            // Hide detailed analysis button
            const detailAnalysisBtn = document.getElementById('detailAnalysisBtn');
            if (detailAnalysisBtn) {
                detailAnalysisBtn.style.display = 'none';
                document.getElementById('downloadAnalysisBtn').style.display = 'none';
            }
            
            // Reset calculation time display
            const timeDiv = document.getElementById('calculation-time');
            if (timeDiv) {
                timeDiv.style.display = 'none';
                timeDiv.textContent = '';
            }
            
            // Show structure status message
            const statusMessage = document.getElementById('structure-status');
            if (statusMessage) {
                statusMessage.style.display = 'block';
            }
            
            // Highlight analyze button with subtle blue emphasis
            const analyzeBtn = document.getElementById('analyze-btn');
            if (analyzeBtn) {
                analyzeBtn.style.background = '#2980b9';  // Darker blue for emphasis
                analyzeBtn.style.boxShadow = '0 0 12px rgba(52, 152, 219, 0.6)';
                analyzeBtn.classList.add('needs-analysis');
            }
            
            console.log('üîÑ Physical properties reset - analysis required');
        }

        function clearStatusMessage() {
            // Hide status message
            const statusMessage = document.getElementById('structure-status');
            if (statusMessage) {
                statusMessage.style.display = 'none';
            }
            
            // Reset analyze button appearance
            const analyzeBtn = document.getElementById('analyze-btn');
            if (analyzeBtn) {
                analyzeBtn.style.background = '';
                analyzeBtn.style.transform = '';
                analyzeBtn.style.boxShadow = '';
                analyzeBtn.classList.remove('needs-analysis');
            }
        }

        // ===== ROBUST 3D DISPLAY CONTROL =====
        // Maximum robustness approach - complete rebuild every time
        
        // Global state variables for maximum reliability - Initial state ON
        let displayUnitCell = true;
        let displayAxes = true;
        let displayBonds = true;
        let currentStructureCif = null;
        
        // Simplified: toggle both unit cell and axes together
        function toggleStructureElementsRobust() {
            // Toggle both together for simplicity
            displayUnitCell = !displayUnitCell;
            displayAxes = displayUnitCell; // Keep them synchronized
            console.log(`üßä ROBUST: Structure elements toggled to: ${displayUnitCell ? 'ON' : 'OFF'}`);
            performCompleteRebuild('STRUCTURE_ELEMENTS_TOGGLE');
        }
        
        // Independent bond toggle function
        function toggleBondsRobust() {
            displayBonds = !displayBonds;
            console.log(`üîó ROBUST: Bonds toggled to: ${displayBonds ? 'ON' : 'OFF'}`);
            updateMoleculeStyleRobust();
        }
        
        // Update molecule style based on bond display state
        function updateMoleculeStyleRobust() {
            if (!window.viewer3D) {
                console.warn('‚ö†Ô∏è ROBUST: No 3D viewer available for style update');
                return;
            }
            
            try {
                const style = { sphere: { scale: 0.3 } };
                if (displayBonds) {
                    style.stick = { radius: 0.1 };
                    console.log('üîó ROBUST: Applying style with bonds');
                } else {
                    console.log('üîó ROBUST: Applying style without bonds');
                }
                
                window.viewer3D.setStyle({}, style);
                window.viewer3D.render();
                syncBondButtonState();
                
                console.log(`‚úÖ ROBUST: Style updated - Bonds: ${displayBonds ? 'ON' : 'OFF'}`);
                
            } catch (error) {
                console.error('‚ùå ROBUST: Failed to update molecule style:', error);
            }
        }
        
        // Complete rebuild function - maximum robustness
        async function performCompleteRebuild(reason) {
            console.log(`üîÑ ROBUST: Starting complete rebuild due to: ${reason}`);
            console.log(`   Target state - UnitCell: ${displayUnitCell}, Axes: ${displayAxes}`);
            
            try {
                // Step 1: Complete destruction with redundant operations
                await performCompleteDestruction();
                
                // Step 2: Rebuild structure from scratch
                await rebuildStructureFromScratch();
                
                // Step 3: Add conditional elements (simplified - axes included in unit cell)
                if (displayUnitCell) {
                    await addUnitCellRobust();
                }
                
                // Step 4: Final rendering
                window.viewer3D.render();
                
                // Step 5: Sync button states
                syncButtonStates();
                
                console.log('‚úÖ ROBUST: Complete rebuild finished successfully');
                
            } catch (error) {
                console.error('‚ùå ROBUST: Rebuild failed:', error);
                handleRebuildError(error, reason);
            }
        }
        
        // Complete destruction with redundant operations
        async function performCompleteDestruction() {
            console.log('üóëÔ∏è ROBUST: Performing complete destruction...');
            
            if (!window.viewer3D) {
                console.warn('‚ö†Ô∏è ROBUST: No 3D viewer available');
                return;
            }
            
            // Multiple attempts to clear everything
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    console.log(`   Destruction attempt ${attempt + 1}/3`);
                    
                    // Clear all content
                    window.viewer3D.clear();
                    
                    // Additional cleanup attempts
                    try { window.viewer3D.removeAllModels(); } catch (e) {}
                    try { window.viewer3D.removeAllShapes(); } catch (e) {}
                    try { window.viewer3D.removeAllLabels(); } catch (e) {}
                    try { window.viewer3D.removeAllSurfaces(); } catch (e) {}
                    try { window.viewer3D.removeUnitCell(); } catch (e) {}
                    
                } catch (error) {
                    console.warn(`   Destruction attempt ${attempt + 1} error:`, error);
                }
            }
            
            console.log('üßπ ROBUST: Complete destruction finished');
        }
        
        // Rebuild structure from scratch
        async function rebuildStructureFromScratch() {
            console.log('üîß ROBUST: Rebuilding structure from scratch...');
            
            try {
                // Get fresh structure data from server
                if (!currentStructureCif) {
                    await fetchCurrentStructureData();
                }
                
                if (!currentStructureCif) {
                    throw new Error('No structure data available');
                }
                
                // Add structure model
                window.viewer3D.addModel(currentStructureCif, 'cif');
                
                // Apply standard styling with bond state consideration
                updateMoleculeStyleRobust();
                
                window.viewer3D.zoomTo();
                
                console.log('üèóÔ∏è ROBUST: Structure rebuilt successfully');
                
            } catch (error) {
                console.error('‚ùå ROBUST: Structure rebuild failed:', error);
                throw error;
            }
        }
        
        // Fetch current structure data
        async function fetchCurrentStructureData() {
            console.log('üåê ROBUST: Fetching current structure data...');
            
            try {
                if (!window.currentFilename || !window.currentSupercellSize) {
                    throw new Error('Missing required parameters');
                }
                
                const params = {
                    filename: window.currentFilename,
                    supercell_size: window.currentSupercellSize,
                    operations: window.atomicOperations || []
                };
                
                console.log('   Parameters:', params);
                
                const response = await fetch('/api/generate-modified-structure-cif', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params)
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }
                
                currentStructureCif = await response.text();
                console.log(`üìÑ ROBUST: Structure data fetched (${currentStructureCif.length} chars)`);
                
            } catch (error) {
                console.error('‚ùå ROBUST: Failed to fetch structure data:', error);
                throw error;
            }
        }
        
        // Add unit cell with robust approach
        async function addUnitCellRobust() {
            console.log('üì¶ ROBUST: Adding unit cell...');
            
            try {
                // Multiple attempts to ensure unit cell is added
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        window.viewer3D.addUnitCell({
                            box: {
                                color: 'black',
                                opacity: 0.8,
                                linewidth: 2
                            },
                            axes: displayAxes,  // Include axes based on state
                            alwaysUseConventionalCell: true,  // Force conventional cell usage
                            scalingFactor: 1.0,  // Ensure 1:1 aspect ratio
                            keepAspectRatio: true  // Maintain proper cubic proportions
                        });
                        console.log(`   Unit cell added successfully (attempt ${attempt + 1})`);
                        break;
                    } catch (error) {
                        console.warn(`   Unit cell attempt ${attempt + 1} failed:`, error);
                        if (attempt === 2) throw error;
                    }
                }
                
            } catch (error) {
                console.error('‚ùå ROBUST: Failed to add unit cell:', error);
                throw error;
            }
        }
        
        // Simplified: Using 3Dmol.js built-in axes functionality through addUnitCell options
        
        // === Clipboard Copy Functionality ===
        
        // Smart clipboard copy with fallback support
        
        
        // Copy energy value functions
        async function copyTotalEnergy() {
            if (!window.energyAnalysisData?.final?.totalEnergy) {
                console.warn('No total energy data available');
                return;
            }
            
            const value = window.energyAnalysisData.final.totalEnergy;
            console.log('Copying total energy (eV):', value);
            const result = await smartCopyToClipboard(value.toString());
            
            const button = document.getElementById('copy-total-energy');
            showCopyFeedback(button, result.success);
        }
        
        
        async function copySiteEnergy(siteIndex) {
            if (!window.currentSiteEnergies || !window.currentSiteEnergies[siteIndex]) {
                console.warn('No site energy data available for index:', siteIndex);
                return;
            }
            
            const value = window.currentSiteEnergies[siteIndex];
            const result = await smartCopyToClipboard(value.toString());
            
            const button = document.getElementById(`copy-site-energy-${siteIndex}`);
            showCopyFeedback(button, result.success);
        }
        
        // Copy magnetic value functions
        async function copyTotalMagnetic() {
            if (!window.currentMagneticData?.totalMagnetic) {
                console.warn('No total magnetic data available');
                return;
            }
            
            const value = window.currentMagneticData.totalMagnetic;
            console.log('Copying total magnetic moment (¬µB):', value);
            const result = await smartCopyToClipboard(value.toFixed(3));
            
            const button = document.getElementById('copy-total-magnetic');
            showCopyFeedback(button, result.success);
        }
        
        async function copySiteMagnetic(siteIndex) {
            if (!window.currentMagneticData?.siteMagnetic || !window.currentMagneticData.siteMagnetic[siteIndex]) {
                console.warn('No site magnetic data available for index:', siteIndex);
                return;
            }
            
            const value = window.currentMagneticData.siteMagnetic[siteIndex];
            const result = await smartCopyToClipboard(value.toFixed(3));
            
            const button = document.getElementById(`copy-site-magnetic-${siteIndex}`);
            showCopyFeedback(button, result.success);
        }

        // Copy all energy data function
        async function copyAllEnergyData() {
            if (!window.energyAnalysisData?.final) {
                console.warn('No energy data available');
                return;
            }
            
            let energyText = '=== Energy Details ===\n';
            const finalData = window.energyAnalysisData.final;
            
            energyText += `Energy per atom: ${finalData.energyPerAtom.toFixed(6)} eV/atom\n`;
            energyText += `Number of atoms: ${finalData.numAtoms} atoms\n`;
            energyText += `Total energy: ${finalData.totalEnergy.toFixed(6)} eV\n`;
            
            // Add site energies if available
            if (window.currentSiteEnergies && window.currentSiteEnergies.length > 0) {
                energyText += '\n=== Site Energies ===\n';
                window.currentSiteEnergies.forEach((energy, i) => {
                    const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Site ${i+1}`;
                    energyText += `${atomLabel}: ${energy.toFixed(6)} eV\n`;
                });
                
                const siteSum = window.currentSiteEnergies.reduce((sum, e) => sum + e, 0);
                energyText += `Sum of site energies: ${siteSum.toFixed(6)} eV\n`;
            }
            
            console.log('Copying all energy data:', energyText);
            const result = await smartCopyToClipboard(energyText);
            
            // Show feedback on any visible energy copy button
            const copyButton = document.querySelector('.copy-btn[onclick="copyAllEnergyData()"]');
            if (copyButton) {
                showCopyFeedback(copyButton, result.success);
            }
        }

        // Copy all magnetic data function
        async function copyAllMagneticData() {
            if (!window.currentMagneticData) {
                console.warn('No magnetic data available');
                return;
            }
            
            let magneticText = '=== Magnetic Details ===\n';
            const magneticData = window.currentMagneticData;
            
            magneticText += `Total |Magnetic Moment|: ${magneticData.totalMagnetic.toFixed(3)} ¬µB\n`;
            
            if (magneticData.siteMagnetic && magneticData.siteMagnetic.length > 0) {
                magneticText += '\n=== Site Magnetic Moments ===\n';
                magneticData.siteMagnetic.forEach((mag, i) => {
                    const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Site ${i+1}`;
                    magneticText += `${atomLabel}: ${mag.toFixed(3)} ¬µB\n`;
                });
            }
            
            console.log('Copying all magnetic data:', magneticText);
            const result = await smartCopyToClipboard(magneticText);
            
            // Show feedback on any visible magnetic copy button
            const copyButton = document.querySelector('.copy-btn[onclick="copyAllMagneticData()"]');
            if (copyButton) {
                showCopyFeedback(copyButton, result.success);
            }
        }

        // Copy formula function
        async function copyFormula(buttonId = null) {
            const formula = getCurrentFormula();
            if (!formula) {
                console.warn('No formula available to copy');
                return;
            }
            
            console.log('Copying formula:', formula);
            const result = await smartCopyToClipboard(formula);
            
            // Find the button that was clicked
            let button = null;
            if (buttonId) {
                button = document.getElementById(buttonId);
            } else {
                // Try to find any visible formula copy button
                const buttonIds = ['copy-formula', 'copy-formula-relaxed', 'copy-formula-supercell'];
                for (const id of buttonIds) {
                    const btn = document.getElementById(id);
                    if (btn && btn.offsetParent !== null) { // Check if button is visible
                        button = btn;
                        break;
                    }
                }
            }
            
            if (button) {
                showCopyFeedback(button, result.success);
            }
        }

        // Get current formula based on available data
        function getCurrentFormula() {
            // Priority 1: Current structure data (after modifications)
            if (window.currentStructureData?.supercell_info?.formula) {
                return window.currentStructureData.supercell_info.formula;
            }
            
            // Priority 2: Relaxed structure info
            if (window.currentStructureInfo?.formula) {
                return window.currentStructureInfo.formula;
            }
            
            // Priority 3: Original crystal data
            if (window.currentCrystalData?.formula) {
                return window.currentCrystalData.formula;
            }
            
            // Fallback: Extract from DOM
            try {
                const formulaElement = document.querySelector('div strong:contains("Formula:") + span, div:contains("Formula:")');
                if (formulaElement) {
                    const text = formulaElement.textContent || formulaElement.innerText;
                    const match = text.match(/Formula:\s*(.+?)(?:\s|$)/);
                    if (match && match[1]) {
                        return match[1].trim();
                    }
                }
            } catch (e) {
                console.warn('Failed to extract formula from DOM:', e);
            }
            
            return null;
        }

        // Copy all crystal information function
        async function copyMainCrystalInfo() {
            // Check if we have relaxed structure data (prioritize over original)
            if (window.currentStructureInfo) {
                // Use relaxed structure data
                const relaxedInfo = window.currentStructureInfo;
                const supercellSize = window.currentSupercellSize || [1, 1, 1];
                const aSize = supercellSize[0];
                const bSize = supercellSize[1];
                const cSize = supercellSize[2];
                
                // Format relaxed crystal information
                const crystalInfoText = `Crystal Information:

Relaxed Supercell Structure Information:
Formula: ${relaxedInfo.formula}
Supercell size: ${aSize} √ó ${bSize} √ó ${cSize}
Total atoms: ${relaxedInfo.num_sites}
Density: ${relaxedInfo.density.toFixed(4)} g/cm¬≥

Relaxed Lattice Parameters:
a = ${relaxedInfo.lattice_parameters.a.toFixed(5)} √Ö
b = ${relaxedInfo.lattice_parameters.b.toFixed(5)} √Ö
c = ${relaxedInfo.lattice_parameters.c.toFixed(5)} √Ö
Œ± = ${relaxedInfo.lattice_parameters.alpha.toFixed(5)}¬∞
Œ≤ = ${relaxedInfo.lattice_parameters.beta.toFixed(5)}¬∞
Œ≥ = ${relaxedInfo.lattice_parameters.gamma.toFixed(5)}¬∞
Volume = ${relaxedInfo.volume.toFixed(5)} ≈≤

‚ö° Structure relaxed with CHGNet
Note: CHGNet may overestimate lattice constants and underestimate density`;
                
                console.log('Copying relaxed crystal information');
                const result = await smartCopyToClipboard(crystalInfoText);
                
                const button = document.getElementById('copy-main-crystal-info');
                showCopyFeedback(button, result.success);
                return;
            }
            
            // Fallback to original supercell data if no relaxed data available
            if (!supercellData) {
                console.warn('No crystal data available');
                return;
            }
            
            const original = supercellData.original_data;
            const supercell = supercellData.supercell_info;
            
            // Calculate supercell lattice parameters
            const aSize = supercell.size[0];
            const bSize = supercell.size[1];
            const cSize = supercell.size[2];
            
            const supercellLattice = {
                a: original.lattice_parameters.a * aSize,
                b: original.lattice_parameters.b * bSize,
                c: original.lattice_parameters.c * cSize,
                alpha: original.lattice_parameters.alpha,
                beta: original.lattice_parameters.beta,
                gamma: original.lattice_parameters.gamma
            };
            
            const supercellDensity = supercell.density || original.density;
            
            // Format original supercell crystal information
            const crystalInfoText = `Crystal Information:

Supercell Structure Information:
Formula: ${supercell.formula}
Supercell size: ${aSize} √ó ${bSize} √ó ${cSize}
Total atoms: ${supercell.num_sites}
Density: ${supercellDensity.toFixed(4)} g/cm¬≥

Supercell Lattice Parameters:
a = ${supercellLattice.a.toFixed(5)} √Ö
b = ${supercellLattice.b.toFixed(5)} √Ö
c = ${supercellLattice.c.toFixed(5)} √Ö
Œ± = ${supercellLattice.alpha.toFixed(5)}¬∞
Œ≤ = ${supercellLattice.beta.toFixed(5)}¬∞
Œ≥ = ${supercellLattice.gamma.toFixed(5)}¬∞
Volume = ${supercell.volume.toFixed(5)} ≈≤

Note: Symmetry information excluded for supercell structure`;
            
            console.log('Copying original crystal information');
            const result = await smartCopyToClipboard(crystalInfoText);
            
            const button = document.getElementById('copy-main-crystal-info');
            showCopyFeedback(button, result.success);
        }
        
        async function copyAllCrystalInfo() {
            if (!window.currentCrystalData) {
                console.warn('No crystal data available');
                return;
            }
            
            const data = window.currentCrystalData;
            
            // Format all crystal information into a readable text
            const crystalInfoText = `Crystal Information:

Basic Structure Information:
Formula: ${data.formula}
Number of atoms: ${data.num_atoms}
Density: ${data.density.toFixed(4)} g/cm¬≥

Lattice Parameters:
a = ${data.lattice_parameters.a.toFixed(5)} √Ö
b = ${data.lattice_parameters.b.toFixed(5)} √Ö
c = ${data.lattice_parameters.c.toFixed(5)} √Ö
Œ± = ${data.lattice_parameters.alpha.toFixed(5)}¬∞
Œ≤ = ${data.lattice_parameters.beta.toFixed(5)}¬∞
Œ≥ = ${data.lattice_parameters.gamma.toFixed(5)}¬∞
Volume = ${data.volume.toFixed(5)} ≈≤

Symmetry Information:
International notation: ${data.space_group}
Space group number: ${data.space_group_number}
Point group: ${data.point_group}
Crystal system: ${data.crystal_system}`;
            
            console.log('Copying all crystal information');
            const result = await smartCopyToClipboard(crystalInfoText);
            
            const button = document.getElementById('copy-crystal-info');
            showCopyFeedback(button, result.success);
        }
        
        // Sync button states with current display state
        function syncButtonStates() {
            console.log('üîÑ ROBUST: Syncing button states...');
            
            const structureBtn = document.getElementById('structureBtn');
            
            if (structureBtn) {
                if (displayUnitCell) {
                    structureBtn.classList.add('active');
                    structureBtn.title = 'Hide Unit Cell & Axes';
                    structureBtn.style.background = 'rgba(76, 175, 80, 0.9)'; // Green when active
                } else {
                    structureBtn.classList.remove('active');
                    structureBtn.title = 'Show Unit Cell & Axes';
                    structureBtn.style.background = 'rgba(255, 255, 255, 0.9)'; // White when inactive
                }
            }
            
            // Also sync bond button
            syncBondButtonState();
            
            console.log(`   Button states synced - Structure: ${displayUnitCell ? 'ON' : 'OFF'}, Bonds: ${displayBonds ? 'ON' : 'OFF'}`);
        }
        
        // Sync bond button state
        function syncBondButtonState() {
            const bondBtn = document.getElementById('bondBtn');
            
            if (bondBtn) {
                if (displayBonds) {
                    bondBtn.classList.add('active');
                    bondBtn.title = 'Hide Bonds';
                    bondBtn.style.background = 'rgba(76, 175, 80, 0.9)'; // Green when active
                } else {
                    bondBtn.classList.remove('active');
                    bondBtn.title = 'Show Bonds';
                    bondBtn.style.background = 'rgba(255, 255, 255, 0.9)'; // White when inactive
                }
            }
        }
        
        // Handle rebuild errors
        function handleRebuildError(error, reason) {
            console.error(`üö® ROBUST: Rebuild error [${reason}]:`, error);
            
            // Reset states on error to initial ON state
            displayUnitCell = true;
            displayAxes = true;
            displayBonds = true;
            syncButtonStates();
            
            // Show error message to user
            const container = document.getElementById('3dmol-viewer');
            if (container) {
                container.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; color: #dc3545; text-align: center; padding: 20px;">
                        <div>
                            <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                            <div style="font-weight: bold; margin-bottom: 5px;">3D Display Error</div>
                            <div style="font-size: 14px;">Failed to rebuild 3D display. Please refresh the page.</div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Lattice data functions removed - using 3Dmol.js built-in functionality
        
        // Reset robust display state
        function resetRobustDisplayState() {
            console.log('üîÑ ROBUST: Resetting display state...');
            displayUnitCell = true;  // Initial state ON
            displayAxes = true;      // Initial state ON
            displayBonds = true;     // Initial state ON
            currentStructureCif = null;
            console.log(`   State reset - UnitCell: ${displayUnitCell}, Axes: ${displayAxes}, Bonds: ${displayBonds}`);
            syncButtonStates();
        }

        function displayMagneticResults(prediction) {
            const magneticItem = document.getElementById('magnetic-item');
            const magneticSummary = document.getElementById('magnetic-summary');
            const magneticTable = document.getElementById('magnetic-table');
            
            if (prediction.magmoms_muB) {
                const magmoms = prediction.magmoms_muB;
                const totalMag = magmoms.reduce((sum, mag) => sum + Math.abs(mag), 0);
                
                // Update status display system
                updateStatusDisplay('magnetic', 'calculated', totalMag, true);
                
                // Store magnetic data for copy functionality
                window.currentMagneticData = {
                    totalMagnetic: totalMag,
                    siteMagnetic: magmoms
                };
                
                let tableHTML = `<tr><th>Magnetic Details</th><th><button class="copy-btn" onclick="copyAllMagneticData()" title="Copy All Magnetic Data">üìã Copy All</button></th></tr>`;
                tableHTML += `<tr><td>Total |Magnetic Moment|:</td><td class="magnetic-moment">${totalMag.toFixed(3)} ¬µB</td></tr>`;
                magmoms.forEach((mag, i) => {
                    // Use current labels to reflect any element substitutions
                    const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Site ${i+1}`;
                    tableHTML += `<tr><td>${atomLabel}:</td><td class="magnetic-moment">${mag.toFixed(3)} ¬µB</td></tr>`;
                });
                magneticTable.innerHTML = tableHTML;
                
                // Details button is now controlled by unified display system
                // No need for manual control here
            } else {
                magneticItem.style.display = 'none';
            }
        }
        
        // displaySiteEnergiesResults function removed - Site Energies are now displayed in Energy details
        
        function displayForcesResults(prediction) {
            const forcesSummary = document.getElementById('forces-summary');
            const forcesTable = document.getElementById('forces-table');
            
            if (prediction.forces_eV_per_A) {
                const forces = prediction.forces_eV_per_A;
                const maxForce = Math.max(...forces.flat().map(Math.abs));
                forcesSummary.innerHTML = `üí™ Forces: <span class="force-vector">Max ${maxForce.toFixed(4)} eV/√Ö</span>`;
                
                let tableHTML = '<table class="detail-table">';
                forces.forEach((force, i) => {
                    const magnitude = Math.sqrt(force[0]**2 + force[1]**2 + force[2]**2);
                    tableHTML += `<tr><td>Atom ${i+1}:</td><td class="force-vector">[${force[0].toFixed(4)}, ${force[1].toFixed(4)}, ${force[2].toFixed(4)}] (|F|=${magnitude.toFixed(4)} eV/√Ö)</td></tr>`;
                });
                tableHTML += '</table>';
                forcesTable.innerHTML = tableHTML;
            } else {
                forcesSummary.textContent = 'üí™ Forces: Not available';
                forcesTable.innerHTML = 'Forces data not available';
            }
        }
        
        function displayStressResults(prediction) {
            const stressSummary = document.getElementById('stress-summary');
            const stressTable = document.getElementById('stress-table');
            
            if (prediction.stress_GPa) {
                const stress = prediction.stress_GPa;
                const maxStress = Math.max(...stress.flat().map(Math.abs));
                stressSummary.innerHTML = `üîß Stress: <span class="force-vector">Max ${maxStress.toFixed(4)} GPa</span>`;
                
                // Matrix display for stress tensor
                let matrixHTML = `
                    <tr><td colspan="2"><strong>Stress Tensor Matrix (GPa):</strong></td></tr>
                    <tr><td colspan="2">
                        <div class="stress-matrix">
                            <table>
                                <tr>
                                    <td>${stress[0][0].toFixed(3)}</td>
                                    <td>${stress[0][1].toFixed(3)}</td>
                                    <td>${stress[0][2].toFixed(3)}</td>
                                </tr>
                                <tr>
                                    <td>${stress[1][0].toFixed(3)}</td>
                                    <td>${stress[1][1].toFixed(3)}</td>
                                    <td>${stress[1][2].toFixed(3)}</td>
                                </tr>
                                <tr>
                                    <td>${stress[2][0].toFixed(3)}</td>
                                    <td>${stress[2][1].toFixed(3)}</td>
                                    <td>${stress[2][2].toFixed(3)}</td>
                                </tr>
                            </table>
                        </div>
                    </td></tr>
                    <tr><td colspan="2"><strong>Individual Components:</strong></td></tr>
                `;
                
                // Add individual components for reference
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        matrixHTML += `<tr><td>œÉ[${i+1},${j+1}]:</td><td class="force-vector">${stress[i][j].toFixed(4)} GPa</td></tr>`;
                    }
                }
                
                stressTable.innerHTML = matrixHTML;
            } else {
                stressSummary.textContent = 'üîß Stress: Not available';
                stressTable.innerHTML = '<tr><td>Stress:</td><td>Not available</td></tr>';
            }
        }
        
        



        async function runCHGNetAnalysis() {
            try {
                // Record start time for calculation duration
                const startTime = performance.now();
                
                // Start processing state with animation
                setCHGNetButtonState('relaxing');
                
                // Update display status to calculating
                updateStatusDisplay('energy', 'calculating');
                updateStatusDisplay('magnetic', 'calculating');
                
                const fmax = parseFloat(document.getElementById('fmax-input').value);
                const maxSteps = parseInt(document.getElementById('max-steps-input').value);
                
                const requestData = {
                    session_id: window.sessionId,
                    fmax: fmax,
                    max_steps: maxSteps
                };
                
                console.log('üî¨ Starting CHGNet analysis:', requestData);
                
                const response = await fetch('/api/chgnet-relax', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during CHGNet analysis.';
                    try {
                        const errorData = await response.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        // If we can't parse JSON, provide user-friendly message
                        if (response.status === 400) {
                            errorMessage = 'Invalid structure data. Fully occupied crystal structure required.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                // Structure calculation phase
                setCHGNetButtonState('calculating_structure');
                
                const data = await response.json();
                console.log('‚úÖ CHGNet analysis completed:', data);
                
                // Properties calculation phase
                setCHGNetButtonState('calculating_properties');
                
                displayCHGNetResults(data, true);
                
                // Update structure information with relaxed data
                if (data.relaxed_structure_info) {
                    updateStructureInformation(data.relaxed_structure_info);
                    // Store structure info globally for download function
                    window.currentStructureInfo = data.relaxed_structure_info;
                }
                
                // Update 3D visualization with relaxed structure
                await updateRelaxed3DVisualization();
                
                // Calculate and display execution time
                const endTime = performance.now();
                const executionTime = ((endTime - startTime) / 1000).toFixed(2);
                
                showNotification(`CHGNet structure analysis completed successfully! (${executionTime}s)`, 'success');
                
                // Display calculation time in results with steps
                const steps = data.relaxation_info?.steps;
                displayCalculationTime(executionTime, steps);
                
                // Clear status message after successful analysis
                clearStatusMessage();
                
                // Restore button to normal state
                setCHGNetButtonState('complete');
                
            } catch (error) {
                console.error('‚ùå CHGNet analysis failed:', error);
                showNotification(`CHGNet analysis failed: ${error.message}`, 'error');
                
                // Restore button on error
                setCHGNetButtonState('complete');
            }
        }

        function updateStructureInformation(relaxedStructureInfo) {
            const infoElement = document.getElementById('main-crystal-info');
            if (!infoElement) return;
            
            infoElement.classList.remove('mock-text');
            
            // Calculate relaxed supercell lattice parameters
            const supercellSize = window.currentSupercellSize || [1, 1, 1];
            const aSize = supercellSize[0];
            const bSize = supercellSize[1];
            const cSize = supercellSize[2];
            
            infoElement.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Relaxed Supercell Structure Information: <a href="/static/user_guide.html#limitations" target="_blank" title="Important: CHGNet may overestimate lattice constants and underestimate density - Click for details" style="color: #e74c3c; text-decoration: none; margin-left: 5px;">‚ö†Ô∏è</a></div>
                    <div><strong>Formula:</strong> ${relaxedStructureInfo.formula}<button class="copy-btn" id="copy-formula-relaxed" onclick="copyFormula('copy-formula-relaxed')" title="Copy: Formula">üìã</button></div>
                    <div><strong>Supercell size:</strong> ${aSize} √ó ${bSize} √ó ${cSize}</div>
                    <div><strong>Total atoms:</strong> ${relaxedStructureInfo.num_sites}</div>
                    <div><strong>Density:</strong> ${relaxedStructureInfo.density.toFixed(4)} g/cm¬≥</div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Relaxed Lattice Parameters:</div>
                    <div style="margin-left: 10px;">
                        a = ${relaxedStructureInfo.lattice_parameters.a.toFixed(5)} √Ö<br>
                        b = ${relaxedStructureInfo.lattice_parameters.b.toFixed(5)} √Ö<br>
                        c = ${relaxedStructureInfo.lattice_parameters.c.toFixed(5)} √Ö<br>
                        Œ± = ${relaxedStructureInfo.lattice_parameters.alpha.toFixed(5)}¬∞<br>
                        Œ≤ = ${relaxedStructureInfo.lattice_parameters.beta.toFixed(5)}¬∞<br>
                        Œ≥ = ${relaxedStructureInfo.lattice_parameters.gamma.toFixed(5)}¬∞<br>
                        Volume = ${relaxedStructureInfo.volume.toFixed(5)} ≈≤
                    </div>
                </div>
                
                
                <div style="font-size: 12px; color: #e74c3c; font-style: italic;">
                    ‚ö° Structure relaxed with CHGNet<br>
                    <span style="font-size: 11px; margin-top: 3px; display: block;">Note: CHGNet may overestimate lattice constants and underestimate density</span>
                </div>
            `;
            
            // Lattice data setup removed - using 3Dmol.js built-in functionality
            // Clear structure cache to force reload with new relaxed data
            currentStructureCif = null;
            
            console.log('‚úÖ Structure information updated with relaxed data');
        }

        async function updateRelaxed3DVisualization() {
            // Performance tracking
            const debugStartTime = performance.now();
            const debugTimestamp = new Date().toISOString();
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`üöÄ RELAXED 3D VISUALIZATION UPDATE START - ${debugTimestamp}`);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // System state validation
            console.log('üîç SYSTEM STATE VALIDATION:');
            console.log(`  ‚îú‚îÄ viewer3D exists: ${!!window.viewer3D}`);
            console.log(`  ‚îú‚îÄ currentFilename: ${window.currentFilename}`);
            console.log(`  ‚îú‚îÄ currentSupercellSize: ${JSON.stringify(window.currentSupercellSize)}`);
            console.log(`  ‚îú‚îÄ sessionId: ${window.sessionId}`);
            console.log(`  ‚îú‚îÄ atomicOperations count: ${window.atomicOperations?.length || 0}`);
            console.log(`  ‚îî‚îÄ browser: ${navigator.userAgent}`);
            
            if (!window.viewer3D || !window.currentFilename || !window.currentSupercellSize) {
                console.warn('‚ö†Ô∏è VALIDATION FAILED: Missing required parameters');
                console.log('  ‚îî‚îÄ Aborting relaxed structure update');
                return;
            }
            
            try {
                console.log('üîÑ STARTING 3D VISUALIZATION UPDATE PROCESS');
                
                // Prepare request data with validation
                const requestData = {
                    session_id: window.sessionId
                };
                console.log('üìã REQUEST DATA PREPARED:');
                console.log(`  ‚îî‚îÄ ${JSON.stringify(requestData, null, 2)}`);
                
                // Network request timing
                const apiStartTime = performance.now();
                console.log('üì° INITIATING API CALL TO /api/generate-relaxed-structure-cif');
                console.log(`  ‚îú‚îÄ Timestamp: ${new Date().toISOString()}`);
                console.log(`  ‚îî‚îÄ Payload size: ${JSON.stringify(requestData).length} bytes`);
                
                const response = await fetch('/api/generate-relaxed-structure-cif', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const apiDuration = performance.now() - apiStartTime;
                console.log('üì° API RESPONSE RECEIVED:');
                console.log(`  ‚îú‚îÄ Status: ${response.status} ${response.statusText}`);
                console.log(`  ‚îú‚îÄ Response time: ${apiDuration.toFixed(2)}ms`);
                console.log(`  ‚îú‚îÄ Content-Type: ${response.headers.get('content-type')}`);
                console.log(`  ‚îú‚îÄ Content-Length: ${response.headers.get('content-length') || 'unknown'}`);
                console.log(`  ‚îî‚îÄ Headers: ${JSON.stringify(Object.fromEntries(response.headers))}`);
                
                if (!response.ok) {
                    console.error('‚ùå API ERROR DETECTED:');
                    const errorText = await response.text();
                    console.error(`  ‚îú‚îÄ Error text length: ${errorText.length}`);
                    console.error(`  ‚îú‚îÄ Error text preview: ${errorText.substring(0, 500)}`);
                    console.error(`  ‚îî‚îÄ Full error text: ${errorText}`);
                    
                    let errorMessage = 'Error occurred while fetching structure data.';
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid structure data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                // CIF data processing
                const cifProcessStart = performance.now();
                console.log('üìÑ PROCESSING CIF DATA:');
                const cifData = await response.text();
                const cifProcessDuration = performance.now() - cifProcessStart;
                
                console.log(`  ‚îú‚îÄ CIF data length: ${cifData.length} characters`);
                console.log(`  ‚îú‚îÄ Processing time: ${cifProcessDuration.toFixed(2)}ms`);
                console.log(`  ‚îú‚îÄ First 300 chars: ${cifData.substring(0, 300)}`);
                console.log(`  ‚îú‚îÄ Contains "data_": ${cifData.includes('data_')}`);
                console.log(`  ‚îú‚îÄ Contains "loop_": ${cifData.includes('loop_')}`);
                console.log(`  ‚îú‚îÄ Contains "_atom_site": ${cifData.includes('_atom_site')}`);
                console.log(`  ‚îî‚îÄ Line count: ${cifData.split('\n').length}`);
                
                // Enhanced CIF validation
                if (!cifData || cifData.length < 100) {
                    console.error('‚ùå CIF VALIDATION FAILED:');
                    console.error(`  ‚îú‚îÄ Data length: ${cifData?.length || 0}`);
                    console.error(`  ‚îú‚îÄ Is null/undefined: ${!cifData}`);
                    console.error(`  ‚îî‚îÄ Content preview: "${cifData?.substring(0, 100) || 'EMPTY'}"`);
                    throw new Error(`Invalid CIF data: ${cifData?.length || 0} characters`);
                }
                
                // 3Dmol processing with detailed logging
                console.log('üéÆ 3DMOL PROCESSING:');
                console.log('  ‚îú‚îÄ Step 1: Clearing existing models');
                const clearStart = performance.now();
                
                // Check current state before clearing with compatibility layer
                const modelsBeforeClear = getViewerModelCount(window.viewer3D);
                console.log(`  ‚îÇ   ‚îú‚îÄ Models before clear: ${modelsBeforeClear}`);
                
                window.viewer3D.clear();
                const clearDuration = performance.now() - clearStart;
                
                const modelsAfterClear = getViewerModelCount(window.viewer3D);
                console.log(`  ‚îÇ   ‚îú‚îÄ Models after clear: ${modelsAfterClear}`);
                console.log(`  ‚îÇ   ‚îî‚îÄ Clear duration: ${clearDuration.toFixed(2)}ms`);
                
                console.log('  ‚îú‚îÄ Step 2: Adding CIF model');
                const addModelStart = performance.now();
                try {
                    const modelResult = window.viewer3D.addModel(cifData, 'cif');
                    const addModelDuration = performance.now() - addModelStart;
                    
                    // Safe logging of modelResult (avoid circular reference)
                    let modelResultInfo = 'unknown';
                    try {
                        if (modelResult === null) {
                            modelResultInfo = 'null';
                        } else if (modelResult === undefined) {
                            modelResultInfo = 'undefined';
                        } else if (typeof modelResult === 'object') {
                            // Get basic info without circular reference
                            const keys = Object.keys(modelResult || {});
                            const type = modelResult.constructor ? modelResult.constructor.name : 'Object';
                            modelResultInfo = `${type} with ${keys.length} properties: [${keys.slice(0, 5).join(', ')}${keys.length > 5 ? '...' : ''}]`;
                        } else {
                            modelResultInfo = String(modelResult);
                        }
                    } catch (e) {
                        modelResultInfo = `[object - unable to serialize: ${e.message}]`;
                    }
                    
                    console.log(`  ‚îÇ   ‚îú‚îÄ addModel result: ${modelResultInfo}`);
                    console.log(`  ‚îÇ   ‚îú‚îÄ Add model duration: ${addModelDuration.toFixed(2)}ms`);
                    const modelsAfterAdd = getViewerModelCount(window.viewer3D);
                    console.log(`  ‚îÇ   ‚îî‚îÄ Models after add: ${modelsAfterAdd}`);
                    
                    if (modelsAfterAdd === 0) {
                        console.error('‚ùå NO MODELS ADDED TO VIEWER:');
                        console.error(`  ‚îú‚îÄ Current model count: ${modelsAfterAdd}`);
                        console.error(`  ‚îú‚îÄ addModel return value: ${modelResultInfo}`);
                        console.error(`  ‚îú‚îÄ CIF data valid: ${!!cifData && cifData.length > 100}`);
                        console.error(`  ‚îî‚îÄ Viewer3D methods: ${Object.getOwnPropertyNames(Object.getPrototypeOf(window.viewer3D)).slice(0, 10).join(', ')}`);
                        throw new Error('Failed to add CIF model to 3Dmol viewer');
                    }
                } catch (addModelError) {
                    console.error('‚ùå ERROR IN addModel:');
                    console.error(`  ‚îú‚îÄ Error message: ${addModelError.message}`);
                    console.error(`  ‚îú‚îÄ Error stack: ${addModelError.stack}`);
                    console.error(`  ‚îî‚îÄ CIF data starts with: ${cifData.substring(0, 100)}`);
                    throw addModelError;
                }
                
                console.log('  ‚îú‚îÄ Step 3: Setting visual style');
                const styleStart = performance.now();
                try {
                    // Apply styling with bond state consideration
                    console.log('  ‚îÇ   ‚îú‚îÄ About to call updateMoleculeStyleRobust()');
                    updateMoleculeStyleRobust();
                    console.log('  ‚îÇ   ‚îú‚îÄ updateMoleculeStyleRobust() completed successfully');
                } catch (styleError) {
                    console.error('‚ùå ERROR in updateMoleculeStyleRobust():');
                    console.error(`  ‚îÇ   ‚îú‚îÄ Error: ${styleError.message}`);
                    console.error(`  ‚îÇ   ‚îî‚îÄ Stack: ${styleError.stack}`);
                    throw styleError;
                }
                const styleDuration = performance.now() - styleStart;
                console.log(`  ‚îÇ   ‚îî‚îÄ Style duration: ${styleDuration.toFixed(2)}ms`);
                
                console.log('  ‚îú‚îÄ Step 4: Adding unit cell (conditional)');
                const unitCellStart = performance.now();
                try {
                    if (displayUnitCell) {
                        console.log('  ‚îÇ   ‚îú‚îÄ About to call addUnitCell()');
                        window.viewer3D.addUnitCell({
                            box: {
                                color: 'black',
                                opacity: 0.8,
                                linewidth: 2
                            },
                            axes: displayAxes  // Include axes based on state
                        });
                        console.log(`  ‚îÇ   ‚îú‚îÄ addUnitCell() completed successfully`);
                        console.log(`  ‚îÇ   ‚îî‚îÄ Unit cell added (state: ON)`);
                    } else {
                        console.log(`  ‚îÇ   ‚îî‚îÄ Unit cell skipped (state: OFF)`);
                    }
                } catch (unitCellError) {
                    console.error('‚ùå ERROR in addUnitCell():');
                    console.error(`  ‚îÇ   ‚îú‚îÄ Error: ${unitCellError.message}`);
                    console.error(`  ‚îÇ   ‚îî‚îÄ Stack: ${unitCellError.stack}`);
                    console.log('  ‚îÇ   ‚îî‚îÄ Continuing without unit cell...');
                    // Don't throw, continue with rendering
                }
                const unitCellDuration = performance.now() - unitCellStart;
                console.log(`  ‚îÇ   ‚îî‚îÄ Unit cell duration: ${unitCellDuration.toFixed(2)}ms`);
                
                console.log('  ‚îú‚îÄ Step 5: Zooming and rendering');
                const renderStart = performance.now();
                try {
                    console.log('  ‚îÇ   ‚îú‚îÄ About to call zoomTo()');
                    window.viewer3D.zoomTo();
                    console.log('  ‚îÇ   ‚îú‚îÄ zoomTo() completed successfully');
                    console.log('  ‚îÇ   ‚îú‚îÄ About to call render()');
                    window.viewer3D.render();
                    console.log('  ‚îÇ   ‚îú‚îÄ render() completed successfully');
                } catch (renderError) {
                    console.error('‚ùå ERROR in rendering:');
                    console.error(`  ‚îÇ   ‚îú‚îÄ Error: ${renderError.message}`);
                    console.error(`  ‚îÇ   ‚îî‚îÄ Stack: ${renderError.stack}`);
                    throw renderError;
                }
                const renderDuration = performance.now() - renderStart;
                console.log(`  ‚îÇ   ‚îî‚îÄ Render duration: ${renderDuration.toFixed(2)}ms`);
                
                console.log('  ‚îî‚îÄ Step 6: Adding status label');
                try {
                    console.log('  ‚îÇ   ‚îú‚îÄ About to call addStructureStatusLabel()');
                    addStructureStatusLabel('relaxed', 'Relaxed Structure');
                    console.log('  ‚îÇ   ‚îî‚îÄ addStructureStatusLabel() completed successfully');
                } catch (labelError) {
                    console.error('‚ùå ERROR in addStructureStatusLabel():');
                    console.error(`  ‚îÇ   ‚îú‚îÄ Error: ${labelError.message}`);
                    console.error(`  ‚îÇ   ‚îî‚îÄ Stack: ${labelError.stack}`);
                    console.log('  ‚îÇ   ‚îî‚îÄ Continuing without status label...');
                    // Don't throw, this is not critical
                }
                
                // Final validation
                const finalModelCount = getViewerModelCount(window.viewer3D);
                const totalDuration = performance.now() - debugStartTime;
                
                console.log('‚úÖ 3D VISUALIZATION UPDATE COMPLETED SUCCESSFULLY:');
                console.log(`  ‚îú‚îÄ Final model count: ${finalModelCount}`);
                console.log(`  ‚îú‚îÄ Total duration: ${totalDuration.toFixed(2)}ms`);
                console.log(`  ‚îú‚îÄ API call: ${apiDuration.toFixed(2)}ms`);
                console.log(`  ‚îú‚îÄ CIF processing: ${cifProcessDuration.toFixed(2)}ms`);
                console.log(`  ‚îî‚îÄ 3Dmol operations: ${(totalDuration - apiDuration - cifProcessDuration).toFixed(2)}ms`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
            } catch (error) {
                const errorDuration = performance.now() - debugStartTime;
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.error('‚ùå RELAXED 3D VISUALIZATION UPDATE FAILED');
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.error('üîç ERROR ANALYSIS:');
                console.error(`  ‚îú‚îÄ Error type: ${error.constructor.name}`);
                console.error(`  ‚îú‚îÄ Error message: ${error.message}`);
                console.error(`  ‚îú‚îÄ Error stack: ${error.stack}`);
                console.error(`  ‚îú‚îÄ Time to failure: ${errorDuration.toFixed(2)}ms`);
                console.error(`  ‚îî‚îÄ Timestamp: ${new Date().toISOString()}`);
                
                console.error('üñ•Ô∏è SYSTEM STATE AT ERROR:');
                console.error(`  ‚îú‚îÄ viewer3D exists: ${!!window.viewer3D}`);
                console.error(`  ‚îú‚îÄ viewer3D models: ${window.viewer3D ? getViewerModelCount(window.viewer3D) : 'N/A'}`);
                console.error(`  ‚îú‚îÄ sessionId: ${window.sessionId}`);
                console.error(`  ‚îú‚îÄ currentFilename: ${window.currentFilename}`);
                console.error(`  ‚îú‚îÄ currentSupercellSize: ${JSON.stringify(window.currentSupercellSize)}`);
                console.error(`  ‚îú‚îÄ DOM container exists: ${!!document.getElementById('3dmol-viewer')}`);
                console.error(`  ‚îú‚îÄ Network status: ${navigator.onLine ? 'online' : 'offline'}`);
                console.error(`  ‚îî‚îÄ Memory usage: ${performance.memory ? `${(performance.memory.usedJSHeapSize/1048576).toFixed(2)}MB` : 'N/A'}`);
                
                // Clear 3D display to avoid showing incorrect structure
                if (window.viewer3D) {
                    console.warn('üßπ CLEANING UP 3D VIEWER');
                    window.viewer3D.clear();
                    
                    // Show clear error message in 3D viewer
                    const container = document.getElementById('3dmol-viewer');
                    if (container) {
                        console.warn('üì∫ DISPLAYING ERROR MESSAGE IN 3D CONTAINER');
                        container.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; border: 2px dashed #dc3545;">
                                <div style="text-align: center; color: #dc3545; font-size: 14px;">
                                    <div style="font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è Failed to Display Relaxed Structure</div>
                                    <div>Could not retrieve accurate structure data</div>
                                    <div style="font-size: 12px; margin-top: 5px; color: #6c757d;">CHGNet calculation completed but 3D display unavailable</div>
                                    <div style="font-size: 10px; margin-top: 10px; color: #868e96;">Error: ${error.message}</div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                showNotification('Failed to display relaxed structure. Calculation data is valid.', 'warning');
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            }
        }

        function resetAnalysis() {
            window.currentCrystalData = null;
            const crystalInfoElement = document.getElementById('crystalInfo');
            crystalInfoElement.classList.add('hidden');
            crystalInfoElement.classList.remove('detailed');
            crystalInfoElement.classList.add('summary');
            document.getElementById('settingsSection').classList.add('hidden');
            document.getElementById('confirmButton').disabled = true;
        }
        
        function validateAtomCount(totalAtoms) {
            // Try modal input first, then fallback to sidebar input
            const modalMaxAtomsInput = document.getElementById('modal-max-atoms-limit');
            const sidebarMaxAtomsInput = document.getElementById('max-atoms-limit');
            const maxAtoms = parseInt(modalMaxAtomsInput?.value || sidebarMaxAtomsInput?.value) || 200;
            
            if (totalAtoms > maxAtoms) {
                alert(`Total atoms (${totalAtoms}) exceeds the system limit (${maxAtoms}).\n\nPlease reduce the supercell dimensions or increase the limit in System Limits settings.`);
                return false;
            }
            return true;
        }

        async function createSupercell() {
            const aSize = document.getElementById('supercell-a').value;
            const bSize = document.getElementById('supercell-b').value;
            const cSize = document.getElementById('supercell-c').value;
            
            // Calculate expected total atoms
            const originalAtoms = window.currentCrystalData?.num_atoms || 1;
            const expectedTotalAtoms = originalAtoms * parseInt(aSize) * parseInt(bSize) * parseInt(cSize);
            
            // Validate against atom limit
            if (!validateAtomCount(expectedTotalAtoms)) {
                return;
            }
            
            
            try {
                const response = await fetch('/api/create-supercell', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        crystal_data: window.currentCrystalData,
                        supercell_size: [parseInt(aSize), parseInt(bSize), parseInt(cSize)],
                        session_id: window.sessionId
                    })
                });
                
                const result = await response.json();
                
                // Store supercell data
                supercellData = result;
                
                // Store immutable original data (never changes)
                window.originalSupercellData = JSON.parse(JSON.stringify(result));
                
                // Set initial density for supercell if not provided
                if (!window.originalSupercellData.supercell_info.density) {
                    window.originalSupercellData.supercell_info.density = window.currentCrystalData.density;
                }
                
                // Initialize current working data (will be modified by operations)
                window.currentStructureData = JSON.parse(JSON.stringify(window.originalSupercellData));
                
                // Store filename and supercell size for 3D visualization
                window.currentFilename = window.currentCrystalData.filename;
                window.currentSupercellSize = [parseInt(aSize), parseInt(bSize), parseInt(cSize)];
                
                // Initialize empty operations history
                window.atomicOperations = [];
                
                // Close modal and proceed to main application
                document.getElementById('cifModal').style.display = 'none';
                
                // Complete data deletion and display supercell info
                completeDataDeletion();
                displaySupercellInfo();
                
                // Robust 3D control system initialization simplified
                resetRobustDisplayState();
                
                // Load element labels for operations
                loadElementLabels();
                
                // Enable reset button
                const resetBtn = document.getElementById('reset-btn');
                if (resetBtn) {
                    resetBtn.disabled = false;
                }
                
                // Initialize 3D viewer (mock for now)
                initializeViewer();
                
                // Enable CHGNet buttons when supercell is created
                enableCHGNetButtons();
                
            } catch (error) {
                console.error('Error creating supercell:', error);
                alert('Error creating supercell');
            }
        }

        function completeDataDeletion() {
            // Complete deletion of original crystal data
            window.currentCrystalData = null;
            
            // Clear all modal content
            document.getElementById('infoContent').innerHTML = '';
            document.getElementById('sampleFileSelect').selectedIndex = 0;
            document.getElementById('uploadFile').value = '';
            
            // Reset supercell inputs
            document.getElementById('supercell-a').value = '1';
            document.getElementById('supercell-b').value = '1';
            document.getElementById('supercell-c').value = '1';
            
            // Clear any temporary variables and references
            if (window.tempCrystalAnalysis) {
                delete window.tempCrystalAnalysis;
            }
            
            // Force garbage collection suggestion
            if (window.gc) {
                window.gc();
            }
            
            console.log('‚úì Complete data deletion performed:');
            console.log('  - window.currentCrystalData set to null');
            console.log('  - Modal content cleared');
            console.log('  - Form inputs reset');
            console.log('  - Temporary variables deleted');
            console.log('  - Memory cleanup suggested');
        }

        function displaySupercellInfo() {
            if (!supercellData) return;
            
            const original = supercellData.original_data;
            const supercell = supercellData.supercell_info;
            
            // Calculate supercell lattice parameters (scaled by supercell dimensions)
            const aSize = supercell.size[0];
            const bSize = supercell.size[1];
            const cSize = supercell.size[2];
            
            const supercellLattice = {
                a: original.lattice_parameters.a * aSize,
                b: original.lattice_parameters.b * bSize,
                c: original.lattice_parameters.c * cSize,
                alpha: original.lattice_parameters.alpha,
                beta: original.lattice_parameters.beta,
                gamma: original.lattice_parameters.gamma
            };
            
            // Calculate supercell density - use current density if available, otherwise original
            const supercellDensity = supercell.density || original.density;
            
            const infoElement = document.getElementById('main-crystal-info');
            infoElement.classList.remove('mock-text');
            infoElement.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Supercell Structure Information:</div>
                    <div><strong>Formula:</strong> ${supercell.formula}<button class="copy-btn" id="copy-formula-supercell" onclick="copyFormula('copy-formula-supercell')" title="Copy: Formula">üìã</button></div>
                    <div><strong>Supercell size:</strong> ${aSize} √ó ${bSize} √ó ${cSize}</div>
                    <div><strong>Total atoms:</strong> ${supercell.num_sites}</div>
                    <div><strong>Density:</strong> ${supercellDensity.toFixed(4)} g/cm¬≥</div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">Supercell Lattice Parameters:</div>
                    <div style="margin-left: 10px;">
                        a = ${supercellLattice.a.toFixed(5)} √Ö<br>
                        b = ${supercellLattice.b.toFixed(5)} √Ö<br>
                        c = ${supercellLattice.c.toFixed(5)} √Ö<br>
                        Œ± = ${supercellLattice.alpha.toFixed(5)}¬∞<br>
                        Œ≤ = ${supercellLattice.beta.toFixed(5)}¬∞<br>
                        Œ≥ = ${supercellLattice.gamma.toFixed(5)}¬∞<br>
                        Volume = ${supercell.volume.toFixed(5)} ≈≤
                    </div>
                </div>
                
                <div style="font-size: 12px; color: #7f8c8d; font-style: italic;">
                    Note: Symmetry information excluded for supercell structure
                </div>
            `;
            
            // Show copy button for main crystal info
            const copyBtn = document.getElementById('copy-main-crystal-info');
            if (copyBtn) {
                copyBtn.style.display = 'inline-flex';
            }
        }

        async function loadCHGnetElements() {
            try {
                const response = await fetch('/api/chgnet-elements');
                const data = await response.json();
                chgnetElements = data.elements || [];
                console.log(`Loaded ${chgnetElements.length} CHGnet supported elements`);
            } catch (error) {
                console.error('Error loading CHGnet elements:', error);
                chgnetElements = [];
            }
        }

        async function loadElementLabels() {
            if (!supercellData) return;
            
            try {
                const response = await fetch('/api/get-element-labels', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: window.sessionId
                    })
                });
                
                const labelData = await response.json();
                
                // Store immutable original labels
                window.originalLabels = [...labelData.labels];
                
                // Initialize current working labels
                window.currentLabels = [...labelData.labels];
                
                displayStructureOperations(window.currentLabels);
                
            } catch (error) {
                console.error('Error loading element labels:', error);
                window.originalLabels = [];
                window.currentLabels = [];
                displayStructureOperations([]);
            }
        }

        function displayStructureOperations(labels) {
            const operationsElement = document.getElementById('structure-operations-content');
            operationsElement.classList.remove('mock-text');
            
            if (labels.length === 0) {
                operationsElement.innerHTML = '<div style="color: #e74c3c;">No element labels available</div>';
                return;
            }
            
            const chgnetOptions = chgnetElements.map(element => 
                `<option value="${element}">${element}</option>`
            ).join('');
            
            operationsElement.innerHTML = `
                <div style="display: flex; gap: 6px; margin-bottom: 15px;">
                    <button class="secondary-action" id="reset-operations-btn" disabled title="Reset operations to return to supercell state" style="flex: 1; padding: 6px 10px; font-size: 12px; font-weight: 500;">
                        üîÑ Reset
                    </button>
                    <button class="secondary-action" id="load-new-cif-btn" onclick="resetAndLoadNewCIF()" title="Reset everything and load a new CIF file" style="flex: 1; padding: 6px 10px; font-size: 12px; font-weight: 500;">
                        üÜï New CIF
                    </button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 14px; font-weight: bold;">Mode:</span>
                    <label style="display: flex; align-items: center; gap: 3px; font-size: 13px; cursor: pointer;"
                           title="Select element type - automatically finds the most energy-stable atom of that type">
                        <input type="radio" name="selection-mode" value="auto" id="auto-mode" checked>Auto
                    </label>
                    <label style="display: flex; align-items: center; gap: 3px; font-size: 13px; cursor: pointer;" 
                           title="Select specific atom by label">
                        <input type="radio" name="selection-mode" value="manual" id="manual-mode">Manual
                    </label>
                </div>
                
                <div class="element-selector" id="manual-selector" style="display: none;">
                    <label for="element-dropdown">Select Atom to Modify:</label>
                    <select id="element-dropdown">
                        <option value="">Choose an atom...</option>
                        ${labels.map(label => `<option value="${label}">${label}</option>`).join('')}
                    </select>
                </div>
                
                <div class="element-selector" id="auto-selector">
                    <label for="element-type-dropdown" 
                           title="Auto mode will test all atoms of this type and select the most energy-stable option">
                        Select Element Type:
                    </label>
                    <select id="element-type-dropdown" 
                            title="Choose an element type to automatically find the optimal atom for modification">
                        <option value="">Choose element type...</option>
                    </select>
                </div>
                
                <div class="control-group" style="margin-bottom: 15px;">
                    <label for="substitute-element">Action:</label>
                    <select id="substitute-element" disabled>
                        <option value="">Select operation...</option>
                        <option value="DELETE">üóëÔ∏è Delete atom</option>
                        <optgroup label="Substitute with:">
                            ${chgnetOptions}
                        </optgroup>
                    </select>
                </div>
                
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="execute-button" id="execute-btn" disabled>
                        Execute
                    </button>
                </div>
                
                <div class="execute-status" id="execute-status" style="display: none;">
                    <div class="status-text" id="execute-status-text">Ready</div>
                    <div class="progress-bar" id="execute-progress-bar" style="display: none;">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="current-best" id="current-best" style="display: none; margin-top: 8px; padding: 6px 8px; background: rgba(46, 204, 113, 0.1); border: 1px solid rgba(46, 204, 113, 0.3); border-radius: 4px; font-size: 11px; color: #27ae60;">
                        <div style="font-weight: bold; margin-bottom: 2px;">Current Best:</div>
                        <div id="current-best-energy" style="font-family: monospace;">-</div>
                        <div id="current-best-atom" style="color: #2c3e50;">-</div>
                    </div>
                    <button class="cancel-btn" id="cancel-btn" style="display: none; margin-top: 8px; padding: 4px 8px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        ‚ùå Cancel Operation
                    </button>
                </div>
            `;
            
            // Extract unique elements from current structure labels
            const uniqueElements = extractUniqueElements(labels);
            
            // Populate element type dropdown with unique elements from current structure
            populateElementTypeDropdown(uniqueElements);
            
            // Add event listeners
            setupOperationListeners();
            
            // Initialize cancel button
            initializeCancelButton();
        }

        function extractUniqueElements(labels) {
            const uniqueElements = new Set();
            labels.forEach(label => {
                // Extract element symbol by removing numbers
                const element = label.replace(/\d+$/, '');
                uniqueElements.add(element);
            });
            return Array.from(uniqueElements).sort();
        }

        function populateElementTypeDropdown(uniqueElements) {
            const elementTypeDropdown = document.getElementById('element-type-dropdown');
            if (!elementTypeDropdown || !uniqueElements) return;
            
            // Clear existing options except the first one
            elementTypeDropdown.innerHTML = '<option value="">Choose element type...</option>';
            
            // Add unique elements from current structure
            uniqueElements.forEach(element => {
                const option = document.createElement('option');
                option.value = element;
                option.textContent = element;
                elementTypeDropdown.appendChild(option);
            });
        }

        function setupOperationListeners() {
            const atomDropdown = document.getElementById('element-dropdown');
            const elementTypeDropdown = document.getElementById('element-type-dropdown');
            const operationSelect = document.getElementById('substitute-element');
            const executeBtn = document.getElementById('execute-btn');
            const resetOperationsBtn = document.getElementById('reset-operations-btn');
            const manualMode = document.getElementById('manual-mode');
            const autoMode = document.getElementById('auto-mode');
            const manualSelector = document.getElementById('manual-selector');
            const autoSelector = document.getElementById('auto-selector');
            
            // Enable reset operations button if original data exists
            if (resetOperationsBtn && window.originalSupercellData && window.originalLabels.length > 0) {
                resetOperationsBtn.disabled = false;
            }
            
            // Initialize Auto mode as default (since auto-mode is checked by default)
            operationSelect.disabled = !elementTypeDropdown.value;
            
            // Selection mode toggle handlers
            manualMode.addEventListener('change', function() {
                if (this.checked) {
                    manualSelector.style.display = 'block';
                    autoSelector.style.display = 'none';
                    // Reset selections
                    elementTypeDropdown.value = '';
                    operationSelect.disabled = !atomDropdown.value;
                    updateExecuteButton();
                }
            });
            
            autoMode.addEventListener('change', function() {
                if (this.checked) {
                    manualSelector.style.display = 'none';
                    autoSelector.style.display = 'block';
                    // Reset selections
                    atomDropdown.value = '';
                    operationSelect.disabled = !elementTypeDropdown.value;
                    updateExecuteButton();
                }
            });
            
            atomDropdown.addEventListener('change', function() {
                const selected = this.value;
                if (manualMode.checked) {
                    operationSelect.disabled = !selected;
                }
                updateExecuteButton();
            });
            
            elementTypeDropdown.addEventListener('change', function() {
                const selected = this.value;
                if (autoMode.checked) {
                    operationSelect.disabled = !selected;
                }
                updateExecuteButton();
            });
            
            operationSelect.addEventListener('change', function() {
                updateExecuteButton();
            });
            
            executeBtn.addEventListener('click', async function(event) {
                event.preventDefault(); // Prevent default button behavior
                
                const selectedOperation = operationSelect.value;
                const isAutoMode = autoMode.checked;
                
                // Get target selection based on mode
                const selectedTarget = isAutoMode ? elementTypeDropdown.value : atomDropdown.value;
                
                if (selectedTarget && selectedOperation) {
                    try {
                        if (isAutoMode) {
                            // Auto mode: Find optimal atom through energy calculations
                            if (selectedOperation === 'DELETE') {
                                await handleOptimalDeletion(selectedTarget);
                            } else {
                                await handleOptimalSubstitution(selectedTarget, selectedOperation);
                            }
                        } else {
                            // Manual mode: Direct operation
                            if (selectedOperation === 'DELETE') {
                                await handleDeletion(selectedTarget);
                            } else {
                                await handleSubstitution(selectedTarget, selectedOperation);
                            }
                        }
                    } catch (error) {
                        console.error('Operation failed:', error);
                        showNotification('Operation failed. Please try again.', 'error');
                    } finally {
                        // Re-enable button
                        executeBtn.disabled = false;
                        updateExecuteButton(); // Restore proper text
                    }
                }
            });
            
            // Reset Operations button listener
            resetOperationsBtn.addEventListener('click', function(event) {
                event.preventDefault();
                resetToOriginalStructure();
            });
        }

        function updateExecuteButton() {
            const atomDropdown = document.getElementById('element-dropdown');
            const elementTypeDropdown = document.getElementById('element-type-dropdown');
            const operationSelect = document.getElementById('substitute-element');
            const executeBtn = document.getElementById('execute-btn');
            const manualMode = document.getElementById('manual-mode');
            
            // Determine current mode and selection
            const isManualMode = manualMode && manualMode.checked;
            const selectedTarget = isManualMode ? atomDropdown.value : elementTypeDropdown.value;
            const selectedOperation = operationSelect.value;
            
            // Enable if both target and operation are selected
            executeBtn.disabled = !selectedTarget || !selectedOperation;
            
            // Update button text based on operation and mode
            if (selectedTarget && selectedOperation) {
                if (selectedOperation === 'DELETE') {
                    if (isManualMode) {
                        executeBtn.textContent = `Delete ${selectedTarget}`;
                    } else {
                        executeBtn.textContent = `Auto Delete ${selectedTarget} (optimal)`;
                    }
                    executeBtn.style.backgroundColor = '#e74c3c'; // Red for deletion
                } else {
                    if (isManualMode) {
                        executeBtn.textContent = `${selectedTarget} ‚Üí ${selectedOperation}`;
                    } else {
                        executeBtn.textContent = `Auto ${selectedTarget} ‚Üí ${selectedOperation} (optimal)`;
                    }
                    executeBtn.style.backgroundColor = '#27ae60'; // Green for substitution
                }
            } else {
                executeBtn.textContent = 'Execute';
                executeBtn.style.backgroundColor = '#27ae60'; // Default green
            }
        }

        async function handleSubstitution(elementLabel, newElement) {
            if (!window.currentStructureData || window.currentLabels.length === 0) {
                showNotification('No structure data available for modification', 'error');
                return;
            }
            
            // Find the atom index
            const atomIndex = window.currentLabels.indexOf(elementLabel);
            if (atomIndex === -1) {
                showNotification(`Atom ${elementLabel} not found`, 'error');
                return;
            }
            
            // Record operation in history
            const oldElement = elementLabel.replace(/\d+$/, ''); // Remove numbers to get element symbol
            window.atomicOperations.push({
                action: "substitute",
                index: atomIndex,
                from: oldElement,
                to: newElement,
                timestamp: Date.now(),
                label: elementLabel
            });
            
            console.log(`üìù Recorded substitution: ${elementLabel} ‚Üí ${newElement} (operation #${window.atomicOperations.length})`);
            
            // Update the structure data
            await updateStructureForSubstitution(atomIndex, elementLabel, newElement);
            
            // Update session with new operations
            await updateSessionWithOperations();
            
            // Reset physical properties after structure modification
            resetPhysicalProperties();
            
            console.log(`‚úì Substituted ${elementLabel} ‚Üí ${newElement}`);
            showNotification(`Successfully substituted ${elementLabel} ‚Üí ${newElement}`, 'success');
        }

        async function handleDeletion(elementLabel) {
            if (!window.currentStructureData || window.currentLabels.length === 0) {
                showNotification('No structure data available for modification', 'error');
                return;
            }
            
            // Find the atom index
            const atomIndex = window.currentLabels.indexOf(elementLabel);
            if (atomIndex === -1) {
                showNotification(`Atom ${elementLabel} not found`, 'error');
                return;
            }
            
            // Record operation in history
            const deletedElement = elementLabel.replace(/\d+$/, ''); // Remove numbers to get element symbol
            window.atomicOperations.push({
                action: "delete",
                index: atomIndex,
                from: deletedElement,
                timestamp: Date.now(),
                label: elementLabel
            });
            
            console.log(`üìù Recorded deletion: ${elementLabel} (operation #${window.atomicOperations.length})`);
            
            // Update the structure data
            await updateStructureForDeletion(atomIndex, elementLabel);
            
            // Update session with new operations
            await updateSessionWithOperations();
            
            // Reset physical properties after structure modification
            resetPhysicalProperties();
            
            console.log(`‚úì Deleted ${elementLabel}`);
            showNotification(`Successfully deleted ${elementLabel}`, 'success');
        }

        async function updateStructureForSubstitution(atomIndex, oldLabel, newElement) {
            // Update the formula by replacing one atom
            const oldElement = oldLabel.replace(/\d+$/, ''); // Remove numbers to get element symbol
            
            // Update labels - replace the substituted atom label
            window.currentLabels[atomIndex] = `${newElement}${atomIndex}`;
            
            // Recalculate formula
            const newFormula = calculateNewFormula(oldElement, newElement);
            window.currentStructureData.supercell_info.formula = newFormula;
            
            // Recalculate density using pymatgen
            const newDensity = await recalculateDensityWithPymatgen(
                newFormula,
                window.currentStructureData.supercell_info.volume,
                window.currentStructureData.original_data?.lattice_parameters || {}
            );
            
            if (newDensity !== null) {
                window.currentStructureData.supercell_info.density = newDensity;
                console.log(`Updated density: ${newDensity.toFixed(4)} g/cm¬≥`);
            } else {
                console.warn('Failed to recalculate density, keeping previous value');
            }
            
            // Update displays
            supercellData = window.currentStructureData; // For compatibility
            displaySupercellInfo();
            displayStructureOperations(window.currentLabels);
            
            // Update 3D visualization
            updateStructureVisualization();
            
            console.log(`Updated formula: ${newFormula}`);
        }

        async function updateStructureForDeletion(atomIndex, deletedLabel) {
            const deletedElement = deletedLabel.replace(/\d+$/, ''); // Remove numbers to get element symbol
            
            // Remove from labels array
            window.currentLabels.splice(atomIndex, 1);
            
            // Update atom count
            window.currentStructureData.supercell_info.num_sites = window.currentLabels.length;
            
            // Recalculate formula
            const newFormula = calculateNewFormulaAfterDeletion(deletedElement);
            window.currentStructureData.supercell_info.formula = newFormula;
            
            // Recalculate volume (approximation - actual volume would need structure recalculation)
            const deletionRatio = window.currentLabels.length / (window.currentLabels.length + 1);
            window.currentStructureData.supercell_info.volume *= deletionRatio;
            
            // Recalculate density using pymatgen
            const newDensity = await recalculateDensityWithPymatgen(
                newFormula,
                window.currentStructureData.supercell_info.volume,
                window.currentStructureData.original_data?.lattice_parameters || {}
            );
            
            if (newDensity !== null) {
                window.currentStructureData.supercell_info.density = newDensity;
                console.log(`Updated density: ${newDensity.toFixed(4)} g/cm¬≥`);
            } else {
                console.warn('Failed to recalculate density, keeping previous value');
            }
            
            // Update displays
            supercellData = window.currentStructureData; // For compatibility
            displaySupercellInfo();
            displayStructureOperations(window.currentLabels);
            
            // Update 3D visualization
            updateStructureVisualization();
            
            console.log(`Updated formula: ${newFormula}`);
            console.log(`Updated atom count: ${window.currentLabels.length}`);
        }

        function calculateNewFormula(oldElement, newElement) {
            const currentFormula = window.currentStructureData.supercell_info.formula;
            
            // Parse current formula
            const elementCounts = {};
            const matches = currentFormula.match(/([A-Z][a-z]?)(\d+)/g) || [];
            
            matches.forEach(match => {
                const element = match.replace(/\d+$/, '');
                const count = parseInt(match.replace(/^[A-Z][a-z]?/, '')) || 1;
                elementCounts[element] = count;
            });
            
            // Update counts
            elementCounts[oldElement] = (elementCounts[oldElement] || 0) - 1;
            if (elementCounts[oldElement] <= 0) {
                delete elementCounts[oldElement];
            }
            
            elementCounts[newElement] = (elementCounts[newElement] || 0) + 1;
            
            // Rebuild formula
            return Object.entries(elementCounts)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([element, count]) => `${element}${count}`)
                .join(' ');
        }

        function calculateNewFormulaAfterDeletion(deletedElement) {
            const currentFormula = window.currentStructureData.supercell_info.formula;
            
            // Parse current formula
            const elementCounts = {};
            const matches = currentFormula.match(/([A-Z][a-z]?)(\d+)/g) || [];
            
            matches.forEach(match => {
                const element = match.replace(/\d+$/, '');
                const count = parseInt(match.replace(/^[A-Z][a-z]?/, '')) || 1;
                elementCounts[element] = count;
            });
            
            // Decrease count for deleted element
            elementCounts[deletedElement] = (elementCounts[deletedElement] || 0) - 1;
            if (elementCounts[deletedElement] <= 0) {
                delete elementCounts[deletedElement];
            }
            
            // Rebuild formula
            return Object.entries(elementCounts)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([element, count]) => `${element}${count}`)
                .join(' ');
        }


        // Execute status functions using same system as Analyze Structure
        function setExecuteButtonState(state, text) {
            const executeBtn = document.getElementById('execute-btn');
            if (!executeBtn) return;

            switch(state) {
                case 'processing':
                    executeBtn.disabled = true;
                    executeBtn.classList.add('button-processing');
                    executeBtn.textContent = text || '‚è≥ Processing...';
                    break;
                case 'complete':
                    executeBtn.disabled = false;
                    executeBtn.classList.remove('button-processing');
                    updateExecuteButton(); // Restore original text
                    break;
                default:
                    executeBtn.disabled = false;
                    executeBtn.classList.remove('button-processing');
                    updateExecuteButton(); // Restore original text
            }
        }

        function showExecuteStatus(message, showProgress = false, showCancel = false) {
            const statusDiv = document.getElementById('execute-status');
            const statusText = document.getElementById('execute-status-text');
            const progressBar = document.getElementById('execute-progress-bar');
            const cancelBtn = document.getElementById('cancel-btn');
            
            statusDiv.style.display = 'block';
            statusText.textContent = message;
            
            if (showProgress) {
                progressBar.style.display = 'block';
            } else {
                progressBar.style.display = 'none';
            }
            
            if (showCancel) {
                cancelBtn.style.display = 'block';
            } else {
                cancelBtn.style.display = 'none';
            }
        }

        function updateExecuteProgress(current, total) {
            const progressBar = document.getElementById('execute-progress-bar');
            const progressFill = progressBar.querySelector('.progress-fill');
            
            if (total === 0) {
                progressFill.style.width = '0%';
                return;
            }
            
            const percentage = Math.min((current / total) * 100, 100);
            progressFill.style.width = `${percentage}%`;
        }

        function hideExecuteStatus() {
            const statusDiv = document.getElementById('execute-status');
            const cancelBtn = document.getElementById('cancel-btn');
            const currentBest = document.getElementById('current-best');
            statusDiv.style.display = 'none';
            cancelBtn.style.display = 'none';
            if (currentBest) {
                currentBest.style.display = 'none';
            }
        }

        // Update current best result during calculation
        function updateCurrentBest(energy, atomLabel, operationType) {
            const currentBest = document.getElementById('current-best');
            const energyElement = document.getElementById('current-best-energy');
            const atomElement = document.getElementById('current-best-atom');
            
            if (!currentBest || !energyElement || !atomElement) {
                return;
            }
            
            // Format energy with appropriate precision
            energyElement.textContent = `${energy.toFixed(6)} eV/atom`;
            
            // Format atom info based on operation type
            if (operationType === 'DELETE') {
                atomElement.textContent = `${atomLabel} (deletion)`;
            } else {
                atomElement.textContent = `${atomLabel} ‚Üí ${operationType}`;
            }
            
            // Show the current best display
            currentBest.style.display = 'block';
        }

        // Hide current best result
        function hideCurrentBest() {
            const currentBest = document.getElementById('current-best');
            if (currentBest) {
                currentBest.style.display = 'none';
            }
        }

        // Global abort controller for canceling operations
        let currentAbortController = null;

        function initializeCancelButton() {
            const cancelBtn = document.getElementById('cancel-btn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function() {
                    if (currentAbortController) {
                        currentAbortController.abort();
                        hideExecuteStatus();
                        hideCurrentBest();
                        setExecuteButtonState('complete');
                        showNotification('‚ö†Ô∏è Operation cancelled by user', 'warning');
                    }
                });
            }
        }

        // Optimal atom selection functions for Auto mode
        async function handleOptimalSubstitution(elementType, newElement) {
            if (!window.currentStructureData || window.currentLabels.length === 0) {
                showNotification('No structure data available for modification', 'error');
                return;
            }
            
            const targetAtoms = findAtomsOfType(elementType);
            
            if (targetAtoms.length === 0) {
                showNotification(`No ${elementType} atoms found in the structure`, 'error');
                return;
            }
            
            // Single atom case: skip optimization and execute directly
            if (targetAtoms.length === 1) {
                const singleAtom = targetAtoms[0];
                
                setExecuteButtonState('processing', '‚è≥ Executing...');
                
                showNotification(
                    `Only one ${elementType} atom found. Executing direct substitution: ${singleAtom.label} ‚Üí ${newElement}`,
                    'info'
                );
                
                try {
                    await handleSubstitution(singleAtom.label, newElement);
                    
                    showNotification(
                        `Direct substitution completed: ${singleAtom.label} ‚Üí ${newElement}`,
                        'success'
                    );
                } catch (error) {
                    console.error('Direct substitution failed:', error);
                    showNotification('Direct substitution failed', 'error');
                } finally {
                    setExecuteButtonState('complete');
                }
                
                return;
            }
            
            // Multiple atoms case: proceed with optimization
            showNotification(
                `Found ${targetAtoms.length} ${elementType} atoms. Starting optimization to find the best substitution...`,
                'info'
            );
            
            // Initialize calculation results tracking
            const calculationResults = {
                successful: [],
                failed: [],
                bestResult: null,
                totalProcessed: 0,
                startTime: Date.now()
            };
            
            currentAbortController = new AbortController();
            setExecuteButtonState('processing', '‚è≥ Starting...');
            showExecuteStatus('Initializing energy calculations...', true, true);
            updateExecuteProgress(0, targetAtoms.length);
            
            try {
                // Test each atom individually with error handling
                for (let i = 0; i < targetAtoms.length; i++) {
                    if (currentAbortController.signal.aborted) {
                        break;
                    }
                    
                    const atom = targetAtoms[i];
                    calculationResults.totalProcessed++;
                    
                    showExecuteStatus(`Testing ${atom.label} ‚Üí ${newElement}... (${i + 1}/${targetAtoms.length})`, true, true);
                    
                    // Use error-handling energy calculation
                    const result = await calculateEnergyWithRetry(
                        atom.label, 
                        { type: 'substitution', newElement }, 
                        currentAbortController.signal
                    );
                    
                    if (currentAbortController.signal.aborted) {
                        break;
                    }
                    
                    if (result.success) {
                        calculationResults.successful.push({
                            atom: atom.label,
                            energy: result.energy,
                            index: atom.index,
                            attempts: result.attempts
                        });
                        
                        // Update best result
                        if (!calculationResults.bestResult || result.energy < calculationResults.bestResult.energy) {
                            calculationResults.bestResult = {
                                atom: atom.label,
                                energy: result.energy,
                                index: atom.index
                            };
                            updateCurrentBest(result.energy, atom.label, newElement);
                        }
                        
                        console.log(`${atom.label} ‚Üí ${newElement}: ${result.energy.toFixed(6)} eV/atom (${result.attempts} attempts)`);
                        
                    } else {
                        calculationResults.failed.push({
                            atom: atom.label,
                            errors: result.errors,
                            finalError: result.finalError
                        });
                        
                        console.warn(`Failed to calculate energy for ${atom.label}: ${result.finalError}`);
                        
                        if (AUTO_MODE_CONFIG.showRealTimeErrors) {
                            updateRealTimeErrorDisplay(atom.label, result.finalError);
                        }
                    }
                    
                    updateExecuteProgress(i + 1, targetAtoms.length);
                }
                
                // Process calculation results
                await processSubstitutionResults(calculationResults, elementType, newElement);
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    return;
                }
                console.error('Fatal error in optimal substitution:', error);
                hideExecuteStatus();
                setExecuteButtonState('complete');
                showNotification('Fatal error during optimal substitution', 'error');
            } finally {
                hideCurrentBest();
                currentAbortController = null;
            }
        }

        async function processSubstitutionResults(results, elementType, newElement) {
            const { successful, failed, bestResult, totalProcessed } = results;
            
            const summary = {
                totalAtoms: totalProcessed,
                successfulCalculations: successful.length,
                failedCalculations: failed.length,
                successRate: totalProcessed > 0 ? ((successful.length / totalProcessed) * 100).toFixed(1) : '0'
            };
            
            if (bestResult) {
                showExecuteStatus('Optimal atom found, executing substitution...', false);
                
                // Display calculation summary
                const resultSummary = successful
                    .sort((a, b) => a.energy - b.energy)
                    .map((r, i) => `${i + 1}. ${r.atom}: ${r.energy.toFixed(6)} eV/atom (${r.attempts} attempts)`)
                    .join('\\n');
                
                console.log(`Energy comparison results (${successful.length}/${totalProcessed} successful):\\n${resultSummary}`);
                
                if (failed.length > 0) {
                    console.warn(`Failed calculations (${failed.length}):`, failed.map(f => `${f.atom}: ${f.finalError}`));
                }
                
                // Execute optimal substitution
                await handleSubstitution(bestResult.atom, newElement);
                
                // Show success notification with statistics
                showNotification(
                    `Optimal substitution completed: ${bestResult.atom} ‚Üí ${newElement} (Success rate: ${summary.successRate}%)`, 
                    'success'
                );
                
                // Show calculation report if there were failures
                if (failed.length > 0) {
                    showCalculationReport(summary, successful, failed, bestResult, 'substitution');
                }
                
            } else {
                // All calculations failed
                showExecuteStatus('No valid calculations completed', false);
                
                console.error(`All ${totalProcessed} substitution calculations failed:`, 
                    failed.map(f => `${f.atom}: ${f.finalError}`));
                
                showNotification(
                    `Auto substitution failed: No atoms could be processed successfully (${failed.length} errors)`, 
                    'error'
                );
                
                showFailureReport(summary, failed, 'substitution');
            }
            
            hideExecuteStatus();
            setExecuteButtonState('complete');
        }

        function showCalculationReport(summary, successful, failed, bestResult, operationType) {
            const reportHtml = `
                <div class="calculation-report">
                    <h4>Auto Mode ${operationType} Report</h4>
                    <div class="summary">
                        <p><strong>Success Rate:</strong> ${summary.successRate}% (${summary.successfulCalculations}/${summary.totalAtoms})</p>
                        <p><strong>Best Result:</strong> ${bestResult.atom} ‚Üí ${bestResult.energy.toFixed(6)} eV/atom</p>
                    </div>
                    
                    ${failed.length > 0 ? `
                        <div class="failed-calculations">
                            <h5>Failed Calculations (${failed.length}):</h5>
                            <ul>
                                ${failed.map(f => `<li><strong>${f.atom}:</strong> ${f.finalError}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <button onclick="this.parentElement.style.display='none'" style="margin-top: 10px;">Close Report</button>
                </div>
            `;
            
            let reportContainer = document.getElementById('calculation-report');
            if (!reportContainer) {
                reportContainer = document.createElement('div');
                reportContainer.id = 'calculation-report';
                reportContainer.className = 'calculation-report-container';
                document.body.appendChild(reportContainer);
            }
            
            reportContainer.innerHTML = reportHtml;
            reportContainer.style.display = 'block';
        }

        function showFailureReport(summary, failed, operationType) {
            const reportHtml = `
                <div class="calculation-report error-report">
                    <h4>Auto Mode ${operationType} - All Calculations Failed</h4>
                    <div class="summary">
                        <p><strong>Total Atoms Tested:</strong> ${summary.totalAtoms}</p>
                        <p><strong>All Failed:</strong> ${failed.length} errors encountered</p>
                    </div>
                    
                    <div class="failed-calculations">
                        <h5>Error Details:</h5>
                        <ul>
                            ${failed.map(f => `<li><strong>${f.atom}:</strong> ${f.finalError}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <button onclick="this.parentElement.style.display='none'" style="margin-top: 10px;">Close Report</button>
                </div>
            `;
            
            let reportContainer = document.getElementById('calculation-report');
            if (!reportContainer) {
                reportContainer = document.createElement('div');
                reportContainer.id = 'calculation-report';
                reportContainer.className = 'calculation-report-container';
                document.body.appendChild(reportContainer);
            }
            
            reportContainer.innerHTML = reportHtml;
            reportContainer.style.display = 'block';
        }

        function updateRealTimeErrorDisplay(atomLabel, errorMessage) {
            let errorContainer = document.getElementById('real-time-errors');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'real-time-errors';
                errorContainer.className = 'real-time-errors';
                
                const statusContainer = document.getElementById('execute-status-container');
                if (statusContainer) {
                    statusContainer.appendChild(errorContainer);
                }
            }
            
            const errorItem = document.createElement('div');
            errorItem.className = 'error-item';
            errorItem.innerHTML = `<span class="atom-label">${atomLabel}:</span> <span class="error-message">${errorMessage}</span>`;
            
            errorContainer.appendChild(errorItem);
            
            // Keep only last 5 errors visible
            while (errorContainer.children.length > 5) {
                errorContainer.removeChild(errorContainer.firstChild);
            }
        }
        
        async function handleOptimalDeletion(elementType) {
            if (!window.currentStructureData || window.currentLabels.length === 0) {
                showNotification('No structure data available for modification', 'error');
                return;
            }
            
            const targetAtoms = findAtomsOfType(elementType);
            
            if (targetAtoms.length === 0) {
                showNotification(`No ${elementType} atoms found in the structure`, 'error');
                return;
            }
            
            // Single atom case: skip optimization and execute directly
            if (targetAtoms.length === 1) {
                const singleAtom = targetAtoms[0];
                
                setExecuteButtonState('processing', '‚è≥ Executing...');
                
                showNotification(
                    `Only one ${elementType} atom found. Executing direct deletion: ${singleAtom.label}`,
                    'info'
                );
                
                try {
                    await handleDeletion(singleAtom.label);
                    
                    showNotification(
                        `Direct deletion completed: ${singleAtom.label} removed`,
                        'success'
                    );
                } catch (error) {
                    console.error('Direct deletion failed:', error);
                    showNotification('Direct deletion failed', 'error');
                } finally {
                    setExecuteButtonState('complete');
                }
                
                return;
            }
            
            // Multiple atoms case: proceed with optimization
            showNotification(
                `Found ${targetAtoms.length} ${elementType} atoms. Starting optimization to find the best deletion...`,
                'info'
            );
            
            // Initialize calculation results tracking
            const calculationResults = {
                successful: [],
                failed: [],
                bestResult: null,
                totalProcessed: 0,
                startTime: Date.now()
            };
            
            currentAbortController = new AbortController();
            setExecuteButtonState('processing', '‚è≥ Starting...');
            showExecuteStatus('Initializing energy calculations...', true, true);
            updateExecuteProgress(0, targetAtoms.length);
            
            try {
                // Test each atom individually with error handling
                for (let i = 0; i < targetAtoms.length; i++) {
                    if (currentAbortController.signal.aborted) {
                        break;
                    }
                    
                    const atom = targetAtoms[i];
                    calculationResults.totalProcessed++;
                    
                    showExecuteStatus(`Testing delete ${atom.label}... (${i + 1}/${targetAtoms.length})`, true, true);
                    
                    // Use error-handling energy calculation
                    const result = await calculateEnergyWithRetry(
                        atom.label, 
                        { type: 'deletion' }, 
                        currentAbortController.signal
                    );
                    
                    if (currentAbortController.signal.aborted) {
                        break;
                    }
                    
                    if (result.success) {
                        calculationResults.successful.push({
                            atom: atom.label,
                            energy: result.energy,
                            index: atom.index,
                            attempts: result.attempts
                        });
                        
                        // Update best result
                        if (!calculationResults.bestResult || result.energy < calculationResults.bestResult.energy) {
                            calculationResults.bestResult = {
                                atom: atom.label,
                                energy: result.energy,
                                index: atom.index
                            };
                            updateCurrentBest(result.energy, atom.label, 'DELETE');
                        }
                        
                        console.log(`Delete ${atom.label}: ${result.energy.toFixed(6)} eV/atom (${result.attempts} attempts)`);
                        
                    } else {
                        calculationResults.failed.push({
                            atom: atom.label,
                            errors: result.errors,
                            finalError: result.finalError
                        });
                        
                        console.warn(`Failed to calculate energy for ${atom.label}: ${result.finalError}`);
                        
                        if (AUTO_MODE_CONFIG.showRealTimeErrors) {
                            updateRealTimeErrorDisplay(atom.label, result.finalError);
                        }
                    }
                    
                    updateExecuteProgress(i + 1, targetAtoms.length);
                }
                
                // Process calculation results
                await processDeletionResults(calculationResults, elementType);
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    return;
                }
                console.error('Fatal error in optimal deletion:', error);
                hideExecuteStatus();
                setExecuteButtonState('complete');
                showNotification('Fatal error during optimal deletion', 'error');
            } finally {
                hideCurrentBest();
                currentAbortController = null;
            }
        }

        async function processDeletionResults(results, elementType) {
            const { successful, failed, bestResult, totalProcessed } = results;
            
            const summary = {
                totalAtoms: totalProcessed,
                successfulCalculations: successful.length,
                failedCalculations: failed.length,
                successRate: totalProcessed > 0 ? ((successful.length / totalProcessed) * 100).toFixed(1) : '0'
            };
            
            if (bestResult) {
                showExecuteStatus('Optimal atom found, executing deletion...', false);
                
                // Display calculation summary
                const resultSummary = successful
                    .sort((a, b) => a.energy - b.energy)
                    .map((r, i) => `${i + 1}. Delete ${r.atom}: ${r.energy.toFixed(6)} eV/atom (${r.attempts} attempts)`)
                    .join('\\n');
                
                console.log(`Energy comparison results (${successful.length}/${totalProcessed} successful):\\n${resultSummary}`);
                
                if (failed.length > 0) {
                    console.warn(`Failed calculations (${failed.length}):`, failed.map(f => `${f.atom}: ${f.finalError}`));
                }
                
                // Execute optimal deletion
                await handleDeletion(bestResult.atom);
                
                // Show success notification with statistics
                showNotification(
                    `Optimal deletion completed: ${bestResult.atom} removed (Success rate: ${summary.successRate}%)`, 
                    'success'
                );
                
                // Show calculation report if there were failures
                if (failed.length > 0) {
                    showCalculationReport(summary, successful, failed, bestResult, 'deletion');
                }
                
            } else {
                // All calculations failed
                showExecuteStatus('No valid calculations completed', false);
                
                console.error(`All ${totalProcessed} deletion calculations failed:`, 
                    failed.map(f => `${f.atom}: ${f.finalError}`));
                
                showNotification(
                    `Auto deletion failed: No atoms could be processed successfully (${failed.length} errors)`, 
                    'error'
                );
                
                showFailureReport(summary, failed, 'deletion');
            }
            
            hideExecuteStatus();
            setExecuteButtonState('complete');
        }
        
        function findAtomsOfType(elementType) {
            const atoms = [];
            window.currentLabels.forEach((label, index) => {
                const element = label.replace(/\d+$/, ''); // Remove numbers to get element symbol
                if (element === elementType) {
                    atoms.push({
                        label: label,
                        index: index,
                        element: element
                    });
                }
            });
            return atoms;
        }
        
        // Error handling configuration
        const ERROR_TYPES = {
            NETWORK: 'network',
            VALIDATION: 'validation',
            COMPUTATION: 'computation', 
            TIMEOUT: 'timeout',
            ABORT: 'abort'
        };

        const ERROR_HANDLING_STRATEGY = {
            [ERROR_TYPES.NETWORK]: 'retry',
            [ERROR_TYPES.VALIDATION]: 'skip',
            [ERROR_TYPES.COMPUTATION]: 'skip', 
            [ERROR_TYPES.TIMEOUT]: 'retry_once',
            [ERROR_TYPES.ABORT]: 'terminate'
        };

        const AUTO_MODE_CONFIG = {
            maxRetries: 2,
            retryDelay: 1000,
            timeoutPerAtom: 30000,
            failureThreshold: 0.5,
            showRealTimeErrors: true,
            continueOnPartialFailure: true
        };

        function classifyError(error) {
            if (error.name === 'AbortError') return ERROR_TYPES.ABORT;
            if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;
            if (error.message.includes('400') || error.message.includes('Invalid')) return ERROR_TYPES.VALIDATION;
            if (error.message.includes('500') || error.message.includes('Server')) return ERROR_TYPES.COMPUTATION;
            return ERROR_TYPES.NETWORK;
        }

        async function calculateEnergyWithRetry(atomLabel, operation, signal, maxRetries = AUTO_MODE_CONFIG.maxRetries) {
            const errors = [];
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    let energy;
                    if (operation.type === 'substitution') {
                        energy = await performSubstitutionCalculation(atomLabel, operation.newElement, signal);
                    } else if (operation.type === 'deletion') {
                        energy = await performDeletionCalculation(atomLabel, signal);
                    }
                    
                    if (energy !== null) {
                        return {
                            success: true,
                            energy: energy,
                            atomLabel: atomLabel,
                            attempts: attempt + 1
                        };
                    } else {
                        throw new Error('Energy calculation returned null');
                    }
                    
                } catch (error) {
                    errors.push({
                        attempt: attempt + 1,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                    
                    const errorType = classifyError(error);
                    const strategy = ERROR_HANDLING_STRATEGY[errorType];
                    
                    if (strategy === 'terminate') {
                        throw error;
                    }
                    
                    if (strategy === 'skip' || 
                        (strategy === 'retry_once' && attempt >= 1) ||
                        attempt >= maxRetries) {
                        break;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, AUTO_MODE_CONFIG.retryDelay * (attempt + 1)));
                }
            }
            
            return {
                success: false,
                atomLabel: atomLabel,
                errors: errors,
                finalError: errors[errors.length - 1]?.error
            };
        }

        async function performSubstitutionCalculation(atomLabel, newElement, signal) {
            try {
                const atomIndex = window.currentLabels.indexOf(atomLabel);
                if (atomIndex === -1) {
                    throw new Error(`Atom ${atomLabel} not found`);
                }
                
                const tempOperations = [...window.atomicOperations, {
                    action: "substitute",
                    index: atomIndex,
                    from: atomLabel.replace(/\d+$/, ''),
                    to: newElement
                }];
                
                const response = await fetch('/api/chgnet-predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: window.currentStructureData?.original_data?.filename || 'structure.cif',
                        operations: tempOperations,
                        supercell_size: window.currentStructureData?.supercell_info?.size || [1, 1, 1]
                    }),
                    signal: signal
                });
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during atom substitution prediction.';
                    try {
                        const errorData = await response.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid structure data or operation.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                
                if (result.status === 'success' && result.prediction?.energy_eV_per_atom) {
                    return result.prediction.energy_eV_per_atom;
                } else {
                    throw new Error('Energy calculation failed: Invalid response format');
                }
                
            } catch (error) {
                throw error;
            }
        }

        async function calculateSubstitutionEnergy(atomLabel, newElement, signal) {
            try {
                return await performSubstitutionCalculation(atomLabel, newElement, signal);
            } catch (error) {
                console.error('Error calculating substitution energy:', error);
                return null;
            }
        }
        
        async function performDeletionCalculation(atomLabel, signal) {
            try {
                const atomIndex = window.currentLabels.indexOf(atomLabel);
                if (atomIndex === -1) {
                    throw new Error(`Atom ${atomLabel} not found`);
                }
                
                const tempOperations = [...window.atomicOperations, {
                    action: "delete",
                    index: atomIndex
                }];
                
                const response = await fetch('/api/chgnet-predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: window.currentStructureData?.original_data?.filename || 'structure.cif',
                        operations: tempOperations,
                        supercell_size: window.currentStructureData?.supercell_info?.size || [1, 1, 1]
                    }),
                    signal: signal
                });
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during atom deletion prediction.';
                    try {
                        const errorData = await response.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid structure data or operation.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                
                if (result.status === 'success' && result.prediction?.energy_eV_per_atom) {
                    return result.prediction.energy_eV_per_atom;
                } else {
                    throw new Error('Energy calculation failed: Invalid response format');
                }
                
            } catch (error) {
                throw error;
            }
        }

        async function calculateDeletionEnergy(atomLabel, signal) {
            try {
                return await performDeletionCalculation(atomLabel, signal);
            } catch (error) {
                console.error('Error calculating deletion energy:', error);
                return null;
            }
        }

        async function resetToOriginalStructure() {
            if (!window.originalSupercellData || window.originalLabels.length === 0) {
                showNotification('No original data to reset to', 'warning');
                return;
            }
            
            if (!window.sessionId) {
                showNotification('No active session found', 'error');
                return;
            }
            
            try {
                // Show reset in progress
                showNotification('Resetting structure...', 'info');
                console.log('üîÑ Starting structure reset...');
                
                // Reset backend session state first
                const response = await fetch('/api/reset-session-structure', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: window.sessionId
                    })
                });
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during session reset.';
                    try {
                        const errorData = await response.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid session data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                console.log('‚úÖ Backend session reset successful:', result);
                
                // Clear frontend operation history
                window.atomicOperations = [];
                console.log('üìù Cleared frontend operation history');
                
                // Restore frontend working data from immutable original data
                window.currentStructureData = JSON.parse(JSON.stringify(window.originalSupercellData));
                window.currentLabels = [...window.originalLabels];
                
                // Update displays
                supercellData = window.currentStructureData; // For compatibility with existing display functions
                displaySupercellInfo();
                displayStructureOperations(window.currentLabels);
                
                // Update 3D visualization
                updateStructureVisualization();
                
                // Clear any previous CHGNet analysis results
                resetPhysicalProperties();
                
                console.log('‚úì Complete structure reset successful');
                console.log(`  - Frontend Formula: ${window.currentStructureData.supercell_info.formula}`);
                console.log(`  - Frontend Atoms: ${window.currentLabels.length}`);
                console.log(`  - Backend Formula: ${result.structure_info.formula}`);
                console.log(`  - Backend Atoms: ${result.structure_info.num_sites}`);
                
                // Verify frontend-backend consistency
                const frontendFormula = window.currentStructureData.supercell_info.formula;
                const backendFormula = result.structure_info.formula;
                
                if (frontendFormula === backendFormula) {
                    showNotification(`Reset complete: ${backendFormula} ‚úì Synchronized`, 'success');
                } else {
                    console.warn('‚ö†Ô∏è Frontend-Backend formula mismatch detected');
                    showNotification(`Reset complete: ${backendFormula} (Note: Sync issue detected)`, 'warning');
                }
                
            } catch (error) {
                console.error('‚ùå Structure reset failed:', error);
                showNotification(`Reset failed: ${error.message}. Please refresh the page.`, 'error');
                
                // Fallback: try frontend-only reset
                try {
                    window.atomicOperations = [];
                    window.currentStructureData = JSON.parse(JSON.stringify(window.originalSupercellData));
                    window.currentLabels = [...window.originalLabels];
                    displaySupercellInfo();
                    displayStructureOperations(window.currentLabels);
                    updateStructureVisualization();
                    console.log('‚ö†Ô∏è Performed frontend-only fallback reset');
                } catch (fallbackError) {
                    console.error('‚ùå Even fallback reset failed:', fallbackError);
                }
            }
        }

        function initializeViewer() {
            console.log('üîÑ Initializing 3D viewer...');
            
            const container = document.getElementById('viewer-container');
            if (!container) {
                console.error('‚ùå viewer-container element not found');
                return;
            }
            
            // Create 3Dmol viewer container optimized for professional crystal analysis
            container.innerHTML = `
                <div style="position: relative; width: 100%; height: 100%; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: white; min-height: 650px;">
                    <div id="3dmol-viewer" style="width: 100%; height: 100%; position: relative; background: white;"></div>
                    
                    <!-- 3D control buttons -->
                    <div class="viewer-controls" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 10;">
                        <button class="control-btn" id="structureBtn" onclick="toggleStructureElementsRobust()" title="Hide Unit Cell & Axes" style="width: 32px; height: 32px; border: none; border-radius: 6px; background: rgba(76, 175, 80, 0.9); backdrop-filter: blur(5px); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: all 0.2s ease;">
                            üßä
                        </button>
                        <button class="control-btn" id="bondBtn" onclick="toggleBondsRobust()" title="Hide Bonds" style="width: 32px; height: 32px; border: none; border-radius: 6px; background: rgba(76, 175, 80, 0.9); backdrop-filter: blur(5px); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: all 0.2s ease;">
                            üîó
                        </button>
                        <button class="control-btn" id="downloadCifBtn" onclick="downloadCurrentCIF()" title="Download Current Structure as CIF" style="width: 32px; height: 32px; border: none; border-radius: 6px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: all 0.2s ease;" onmouseover="this.style.background='rgba(33, 150, 243, 0.9)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.9)'">
                            üíæ
                        </button>
                    </div>
                </div>
            `;
            
            console.log('‚úÖ 3D viewer container created');
            
            // Use already loaded 3Dmol.js from HTML script tag
            if (typeof $3Dmol === 'undefined') {
                console.error('‚ùå 3Dmol.js not loaded. Check script tag in HTML head.');
                return;
            }
            
            console.log('‚úÖ 3Dmol.js already loaded via script tag');
            
            const element = document.getElementById('3dmol-viewer');
            if (!element) {
                console.error('‚ùå 3dmol-viewer element not found');
                return;
            }
            
            // Create 3Dmol viewer with proper aspect ratio settings
            const config = { 
                backgroundColor: 'white',
                orthographic: false,  // Use perspective projection for better depth perception
                antialias: true,  // Smooth edges
                preserveAspectRatio: true,  // Maintain proper proportions
                disableInternalControls: false  // Allow rotation/zoom
            };
            window.viewer3D = $3Dmol.createViewer(element, config);
            
            console.log('‚úÖ 3Dmol.js viewer initialized');
            console.log(`‚úÖ Available methods: ${Object.getOwnPropertyNames(window.viewer3D).filter(m => typeof window.viewer3D[m] === 'function').slice(0, 10).join(', ')}`);
            
            // Load supercell visualization
            loadSupercellVisualization();
        }

        // 3Dmol.js API compatibility layer for different versions
        function getViewerModelCount(viewer) {
            try {
                // Try different possible method names across 3Dmol.js versions
                if (typeof viewer.getNumModels === 'function') {
                    return viewer.getNumModels();
                }
                if (typeof viewer.getModelCount === 'function') {
                    return viewer.getModelCount();
                }
                if (typeof viewer.numModels === 'number') {
                    return viewer.numModels;
                }
                if (viewer.models && Array.isArray(viewer.models)) {
                    return viewer.models.length;
                }
                if (viewer.model && viewer.model.length) {
                    return viewer.model.length;
                }
                
                // Fallback: check internal structure
                console.warn('‚ö†Ô∏è Unknown 3Dmol.js API version, using fallback method');
                const methods = Object.getOwnPropertyNames(viewer);
                console.log(`üìã Available viewer properties/methods: ${methods.slice(0, 20).join(', ')}`);
                
                // Return 1 if viewer exists and has been initialized, 0 otherwise
                return viewer ? 1 : 0;
                
            } catch (error) {
                console.error('‚ùå Error in getViewerModelCount:', error);
                return 0;
            }
        }

        function loadScript(src, callback) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = function() {
                console.log(`‚úì Script loaded successfully: ${src}`);
                callback();
            };
            script.onerror = function() {
                console.error(`‚úó Failed to load script: ${src}`);
            };
            document.head.appendChild(script);
        }


        async function loadSupercellVisualization() {
            console.log('üîÑ Loading supercell structure for 3D visualization');
            
            if (!window.viewer3D) {
                console.warn('‚ùå 3D viewer not initialized yet');
                return;
            }
            
            if (!window.currentFilename || !window.currentSupercellSize) {
                console.warn('‚ùå No filename or supercell size available');
                return;
            }
            
            try {
                console.log(`üìä Using direct CIF generation approach`);
                console.log(`üìÑ Filename: ${window.currentFilename}`);
                console.log(`üìê Supercell size: ${window.currentSupercellSize}`);
                
                // Use new direct CIF generation API
                const requestData = {
                    filename: window.currentFilename,
                    supercell_size: window.currentSupercellSize,
                    session_id: window.sessionId
                };
                
                console.log('üì° Requesting supercell CIF from direct API...');
                const response = await fetch('/api/generate-supercell-cif-direct', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log(`üì° Response status: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during supercell generation.';
                    try {
                        const errorText = await response.text();
                        const errorData = JSON.parse(errorText);
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid parameters or structure data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const cifData = await response.text();
                console.log(`üìÑ Generated supercell CIF data: ${cifData.length} characters`);
                
                // Display structure using fastapiBT.py approach
                console.log('üóëÔ∏è Clearing existing models');
                window.viewer3D.clear();
                
                console.log('‚ûï Adding supercell CIF model');
                window.viewer3D.addModel(cifData, 'cif');
                
                console.log('üé® Setting molecular style with bond state');
                // Apply styling with bond state consideration
                updateMoleculeStyleRobust();
                
                console.log('üì¶ Adding unit cell (conditional)');
                if (displayUnitCell) {
                    window.viewer3D.addUnitCell({
                        box: {
                            color: 'black',
                            opacity: 0.8,
                            linewidth: 2
                        },
                        axes: displayAxes  // Include axes based on state
                    });
                    console.log('   Unit cell added (state: ON)');
                } else {
                    console.log('   Unit cell skipped (state: OFF)');
                }
                
                console.log('üîç Zooming and rendering');
                window.viewer3D.zoomTo();
                window.viewer3D.render();
                
                // Add status label for supercell
                const sizeStr = window.currentSupercellSize.join('x');
                addStructureStatusLabel('supercell', `Supercell (${sizeStr})`);
                
                console.log('‚úÖ Successfully loaded 3D supercell visualization');
                
            } catch (error) {
                console.error('‚ùå Error loading supercell 3D structure:', error);
                
                // Fallback: show error message in viewer
                const container = document.getElementById('3dmol-viewer');
                if (container) {
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; text-align: center; padding: 20px;">
                            <div>
                                <div style="font-size: 18px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                                <div>Failed to load 3D structure</div>
                                <div style="font-size: 12px; margin-top: 5px;">${error.message}</div>
                            </div>
                        </div>
                    `;
                }
            }
        }

        async function updateStructureVisualization() {
            if (!window.viewer3D || !window.currentFilename || !window.currentSupercellSize) {
                console.log('3D viewer or structure parameters not available, skipping update');
                return;
            }
            
            try {
                console.log('üîÑ Updating 3D visualization with operation history');
                console.log(`üìã Operations to apply: ${window.atomicOperations.length}`);
                
                // Use operation history to regenerate complete structure
                const requestData = {
                    filename: window.currentFilename,
                    supercell_size: window.currentSupercellSize,
                    operations: window.atomicOperations
                };
                
                console.log('üì° Requesting structure with operations from API...');
                const response = await fetch('/api/generate-modified-structure-cif', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                console.log(`üì° Response status: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    let errorMessage = 'Error occurred during structure modification.';
                    try {
                        const errorText = await response.text();
                        const errorData = JSON.parse(errorText);
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Invalid parameters or structure data.';
                        } else if (response.status === 500) {
                            errorMessage = 'Server error occurred. Please try again later.';
                        }
                    }
                    throw new Error(errorMessage);
                }
                
                const cifData = await response.text();
                console.log(`üìÑ Generated modified CIF data: ${cifData.length} characters`);
                
                // Update 3D viewer with modified structure
                console.log('üóëÔ∏è Clearing existing models');
                window.viewer3D.clear();
                
                console.log('‚ûï Adding modified structure CIF model');
                window.viewer3D.addModel(cifData, 'cif');
                
                console.log('üé® Setting molecular style with bond state');
                // Apply styling with bond state consideration
                updateMoleculeStyleRobust();
                
                console.log('üì¶ Adding unit cell (conditional)');
                if (displayUnitCell) {
                    window.viewer3D.addUnitCell({
                        box: {
                            color: 'black',
                            opacity: 0.8,
                            linewidth: 2
                        },
                        axes: displayAxes  // Include axes based on state
                    });
                    console.log('   Unit cell added (state: ON)');
                } else {
                    console.log('   Unit cell skipped (state: OFF)');
                }
                
                console.log('üîç Zooming and rendering');
                window.viewer3D.zoomTo();
                window.viewer3D.render();
                
                // Add status label for modified structure
                const operationsText = window.atomicOperations.length > 0 
                    ? `Modified (${window.atomicOperations.length} ops)` 
                    : 'Original Structure';
                addStructureStatusLabel('modified', operationsText);
                
                console.log(`‚úÖ 3D structure updated with ${window.atomicOperations.length} operations`);
                
            } catch (error) {
                console.error('‚ùå Error updating 3D visualization:', error);
                
                // Clear 3D display to avoid showing incorrect structure
                if (window.viewer3D) {
                    window.viewer3D.clear();
                    
                    // Show clear error message in 3D viewer
                    const container = document.getElementById('3dmol-viewer');
                    if (container) {
                        container.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; border: 2px dashed #ffc107;">
                                <div style="text-align: center; color: #856404; font-size: 14px;">
                                    <div style="font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è Failed to Display Structure</div>
                                    <div>Could not retrieve accurate structure data</div>
                                    <div style="font-size: 12px; margin-top: 5px; color: #6c757d;">Operations are recorded but 3D display unavailable</div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                showNotification('Failed to display structure. Operation data is preserved.', 'warning');
            }
        }

        function addStructureStatusLabel(type, label) {
            const container = document.getElementById('3dmol-viewer');
            if (!container) return;
            
            // Remove existing status label
            const existing = container.querySelector('.structure-status-label');
            if (existing) existing.remove();
            
            // Add new status label
            const statusDiv = document.createElement('div');
            statusDiv.className = 'structure-status-label';
            statusDiv.style.cssText = `
                position: absolute; top: 10px; left: 10px; z-index: 100;
                background: ${type === 'relaxed' ? 'rgba(40, 167, 69, 0.9)' : 'rgba(23, 162, 184, 0.9)'};
                color: white; padding: 6px 12px; border-radius: 4px;
                font-size: 12px; font-weight: 500;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            `;
            statusDiv.textContent = label;
            container.appendChild(statusDiv);
        }

        async function recalculateDensityWithPymatgen(formula, volume, latticeParameters) {
            /**
             * Recalculate density using pymatgen backend API
             */
            try {
                const response = await fetch('/api/recalculate-density', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        formula: formula,
                        volume: volume,
                        lattice_parameters: latticeParameters
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    return data.density;
                } else {
                    console.error('Error recalculating density:', data);
                    return null;
                }
                
            } catch (error) {
                console.error('Error calling density recalculation API:', error);
                return null;
            }
        }


        function showNotification(message, type = 'info') {
            // Remove existing notification if present
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            // Set colors based on type
            const colors = {
                'success': { bg: '#2ecc71', text: 'white' },
                'error': { bg: '#e74c3c', text: 'white' },
                'warning': { bg: '#f39c12', text: 'white' },
                'info': { bg: '#3498db', text: 'white' }
            };
            
            const color = colors[type] || colors.info;
            
            // Style the notification
            Object.assign(notification.style, {
                position: 'fixed',
                top: '20px',
                right: '20px',
                backgroundColor: color.bg,
                color: color.text,
                padding: '12px 20px',
                borderRadius: '4px',
                boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
                zIndex: '10000',
                fontSize: '14px',
                maxWidth: '300px',
                opacity: '0',
                transform: 'translateY(-20px)',
                transition: 'all 0.3s ease'
            });
            
            // Add to page
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function setupCrystalInfoToggle() {
            const crystalInfoElement = document.getElementById('crystalInfo');
            const toggleElement = document.getElementById('expandToggle');
            
            if (!crystalInfoElement || !toggleElement) return;
            
            // Add click handlers for both the toggle button and the summary area
            const toggleHandler = function() {
                if (crystalInfoElement.classList.contains('summary')) {
                    // Expand to detailed view
                    crystalInfoElement.classList.remove('summary');
                    crystalInfoElement.classList.add('detailed');
                    toggleElement.textContent = '‚ñ≤ Collapse';
                } else {
                    // Collapse to summary view
                    crystalInfoElement.classList.remove('detailed');
                    crystalInfoElement.classList.add('summary');
                    toggleElement.textContent = '‚ñº Details';
                }
            };
            
            // Remove existing listeners to prevent duplicates
            const newToggleElement = toggleElement.cloneNode(true);
            toggleElement.parentNode.replaceChild(newToggleElement, toggleElement);
            
            // Add click listener to toggle button
            newToggleElement.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleHandler();
            });
            
            // Add click listener to the summary area (only when in summary mode)
            crystalInfoElement.addEventListener('click', function(e) {
                if (crystalInfoElement.classList.contains('summary') && 
                    !e.target.classList.contains('expand-toggle')) {
                    toggleHandler();
                }
            });
        }

        // Analysis Modal Functions
        window.currentAnalysisData = null;

        function openAnalysisModal() {
            console.log('=== openAnalysisModal called ===');
            const modal = document.getElementById('analysisModal');
            modal.style.display = 'block';
            
            console.log('currentAnalysisData:', currentAnalysisData);
            if (currentAnalysisData) {
                console.log('Populating modal with data...');
                populateAnalysisModal(currentAnalysisData);
            } else {
                console.warn('No currentAnalysisData available!');
            }
            
            // Set default active tab to energy (Relaxation)
            console.log('Switching to energy tab...');
            switchTab('energy');
            
            // Add escape key listener
            document.addEventListener('keydown', handleModalKeydown);
            console.log('=== openAnalysisModal completed ===');
        }

        function closeAnalysisModal() {
            const modal = document.getElementById('analysisModal');
            modal.style.display = 'none';
            document.removeEventListener('keydown', handleModalKeydown);
        }

        function resetAndLoadNewCIF() {
            // Show confirmation dialog if there's existing data
            if (window.currentFilename || window.currentAnalysisData) {
                const confirmed = confirm('This will reset all current analysis data and structure modifications. Continue?');
                if (!confirmed) {
                    return;
                }
            }
            
            // Clear all current data and reset application state
            resetApplicationState();
            
            // Initialize crystal info state when modal opens
            hideCrystalInfoCompletely();
            
            // Show the CIF selection modal
            const modal = document.getElementById('cifModal');
            modal.style.display = 'block';
        }
        
        function openCifSelectionModal() {
            // Keep the original function for backwards compatibility
            resetAndLoadNewCIF();
        }
        
        function resetApplicationState() {
            // Clear global variables
            window.currentFilename = null;
            window.currentSupercellSize = null;
            window.originalLabels = [];
            window.currentLabels = [];
            window.currentAnalysisData = null;
            window.currentStructureData = null;
            window.operationHistory = [];
            
            // Clear 3D viewer
            if (window.viewer3D) {
                window.viewer3D.clear();
                window.viewer3D.render();
            }
            
            // Reset viewer container to initial state
            const viewerContainer = document.querySelector('.viewer-container');
            if (viewerContainer) {
                viewerContainer.innerHTML = 'Load a CIF file to view the crystal structure';
                viewerContainer.style.color = '#666';
                viewerContainer.style.fontSize = '18px';
            }
            
            // Clear analysis data and reset UI elements
            const analysisContainer = document.getElementById('analysis-container');
            if (analysisContainer) {
                analysisContainer.innerHTML = '';
            }
            
            // Reset main crystal info
            const mainCrystalInfo = document.getElementById('main-crystal-info');
            if (mainCrystalInfo) {
                mainCrystalInfo.innerHTML = '<div class="mock-text">Structure details will be displayed here</div>';
                mainCrystalInfo.className = 'mock-text';
            }
            
            // Reset structure operations
            const structureOps = document.getElementById('structure-operations-content');
            if (structureOps) {
                structureOps.innerHTML = '<div class="mock-text">Element substitution and deletion controls</div>';
                structureOps.className = 'mock-text';
            }
            
            // Reset form elements and buttons
            const resetBtn = document.getElementById('reset-operations-btn');
            if (resetBtn) {
                resetBtn.disabled = true;
            }
            
            const chgnetBtn = document.getElementById('chgnet-analyze-btn');
            if (chgnetBtn) {
                chgnetBtn.disabled = true;
                chgnetBtn.textContent = 'üß† Run CHGNet Analysis';
            }
            
            const detailBtn = document.getElementById('detail-analysis-btn');
            if (detailBtn) {
                detailBtn.style.display = 'none';
            }
            
            const downloadBtn = document.getElementById('download-analysis-btn');
            if (downloadBtn) {
                downloadBtn.style.display = 'none';
            }
            
            // Reset supercell inputs
            document.getElementById('supercell-a').value = '1';
            document.getElementById('supercell-b').value = '1';
            document.getElementById('supercell-c').value = '1';
            
            console.log('‚úì Application state completely reset for new CIF loading');
        }

        function handleModalKeydown(event) {
            if (event.key === 'Escape') {
                closeAnalysisModal();
            }
        }

        function switchTab(tabName) {
            console.log('=== switchTab called ===');
            console.log('Tab name:', tabName);
            console.log('currentAnalysisData:', currentAnalysisData);
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback when called programmatically
                document.querySelector(`[onclick="switchTab('${tabName}')"]`)?.classList.add('active');
            }
            
            // Update tab content
            document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Load tab-specific content
            if (tabName === 'energy') {
                // Use currentAnalysisData if available
                if (currentAnalysisData) {
                    populateEnergyAnalysisTab(currentAnalysisData);
                    drawCharts(currentAnalysisData);
                } else {
                    console.warn('No currentAnalysisData available for energy tab');
                }
            }
        }

        function populateAnalysisModal(data) {
            console.log('=== populateAnalysisModal called ===');
            console.log('Data received:', data);
            
            // Summary Tab (now moved to Relaxation tab)
            console.log('Calling populateSummaryTab...');
            populateSummaryTab(data);
            
            // Data Tab
            console.log('Calling populateDataTab...');
            populateDataTab(data);
            
            // Energy Analysis Tab (Relaxation tab)
            console.log('Calling populateEnergyAnalysisTab...');
            populateEnergyAnalysisTab(data);
            
            console.log('=== populateAnalysisModal completed ===');
            // Charts will be drawn when tab is selected
        }
        
        function populateEnergyAnalysisTab(data) {
            console.log('=== populateEnergyAnalysisTab called ===');
            console.log('Data received:', data);
            
            const energyTableBody = document.getElementById('energy-analysis-body');
            const energyInsights = document.getElementById('energy-insights');
            
            console.log('Elements found:');
            console.log('- energyTableBody:', energyTableBody);
            console.log('- energyInsights:', energyInsights);
            
            if (!data || !data.initial_prediction || !data.final_prediction) {
                console.log('No energy data available');
                energyTableBody.innerHTML = '<tr><td colspan="4">No energy data available</td></tr>';
                energyInsights.innerHTML = '<p>Energy analysis requires completed relaxation calculation.</p>';
                return;
            }
            
            console.log('Populating energy analysis table...');
            
            // Generate table HTML using passed data
            let tableHTML = '';
            
            // Get initial and final predictions
            const initialPred = data.initial_prediction;
            const finalPred = data.final_prediction;
            
            // Always show final structure data
            if (finalPred) {
                // Calculate number of atoms
                const numAtoms = data.structure_info?.num_atoms || finalPred.forces_eV_per_A?.length || 0;
                
                // Calculate energies
                const initialTotalEnergy = initialPred ? (initialPred.total_energy_eV !== undefined ? initialPred.total_energy_eV : initialPred.energy_eV_per_atom * numAtoms) : null;
                const finalTotalEnergy = finalPred.total_energy_eV !== undefined ? finalPred.total_energy_eV : finalPred.energy_eV_per_atom * numAtoms;
                const energyChange = initialTotalEnergy ? finalTotalEnergy - initialTotalEnergy : null;
                const energyChangePerAtom = data.energy_change_eV_per_atom || 0;
                
                tableHTML += `
                    <tr>
                        <td><strong>Number of atoms</strong></td>
                        <td>${numAtoms || '-'}</td>
                        <td>${numAtoms || '-'}</td>
                    </tr>
                    <tr>
                        <td><strong>Total Energy (eV)</strong></td>
                        <td>${initialTotalEnergy ? initialTotalEnergy.toFixed(6) : '-'}</td>
                        <td><span class="${finalPred.energy_eV_per_atom < 0 ? 'energy-negative' : 'energy-positive'}">${finalTotalEnergy.toFixed(6)}</span></td>
                    </tr>
                    <tr>
                        <td><strong>Energy per atom (eV/atom)</strong></td>
                        <td>${initialPred ? initialPred.energy_eV_per_atom.toFixed(6) : '-'}</td>
                        <td><span class="${finalPred.energy_eV_per_atom < 0 ? 'energy-negative' : 'energy-positive'}">${finalPred.energy_eV_per_atom.toFixed(6)}</span></td>
                    </tr>
                `;
            }
            
            energyTableBody.innerHTML = tableHTML;
            
            // Generate insights
            let insights = '<h4>Energy Analysis Insights:</h4><ul>';
            
            if (data.final) {
                const stability = data.final.energyPerAtom < 0 ? 'stable' : 'unstable';
                insights += `<li><strong>Stability:</strong> The final structure is ${stability} with ${data.final.energyPerAtom.toFixed(3)} eV/atom.</li>`;
                
                insights += `<li><strong>System Size:</strong> Calculation performed on ${data.final.numAtoms} atoms.</li>`;
            }
            
            insights += '</ul>';
            energyInsights.innerHTML = insights;
        }
        
        function getChangeDisplay(change) {
            const sign = change >= 0 ? '+' : '';
            const colorClass = change < 0 ? 'energy-negative' : 'energy-positive';
            return `<span class="${colorClass}">${sign}${change.toFixed(6)}</span>`;
        }

        function populateSummaryTab(data) {
            console.log('=== populateSummaryTab called ===');
            console.log('Data received:', data);
            
            const convergenceEl = document.getElementById('summary-convergence');
            const energyEl = document.getElementById('summary-energy');
            const forcesEl = document.getElementById('summary-forces');
            const stressEl = document.getElementById('summary-stress');
            const settingsEl = document.getElementById('relaxation-settings');
            
            console.log('Elements found:');
            console.log('- convergenceEl:', convergenceEl);
            console.log('- energyEl:', energyEl);
            console.log('- forcesEl:', forcesEl);
            console.log('- stressEl:', stressEl);
            console.log('- settingsEl:', settingsEl);
            
            // Convergence Status
            const converged = data.relaxation_info?.converged;
            convergenceEl.innerHTML = `
                <div class="${converged ? 'convergence-success' : 'convergence-failed'}">
                    ${converged ? '‚úÖ Converged' : '‚ùå Not Converged'}
                </div>
                <div style="font-size: 14px; margin-top: 5px;">
                    ${data.relaxation_info?.steps || 0} steps completed
                </div>
            `;
            
            // Energy Values (Initial and Final only)
            energyEl.innerHTML = `
                <div style="font-size: 14px;">
                    Initial: ${data.initial_prediction?.energy_eV_per_atom?.toFixed(6) || 'N/A'} eV/atom<br>
                    Final: ${data.final_prediction?.energy_eV_per_atom?.toFixed(6) || 'N/A'} eV/atom
                </div>
            `;
            
            // Force Information
            if (data.trajectory_data?.force_magnitudes?.length > 0) {
                const finalForces = data.trajectory_data.force_magnitudes[data.trajectory_data.force_magnitudes.length - 1];
                const maxFinalForce = Math.max(...finalForces);
                const rmsFinalForce = Math.sqrt(finalForces.reduce((sum, f) => sum + f*f, 0) / finalForces.length);
                
                forcesEl.innerHTML = `
                    <div>Max Force: ${maxFinalForce.toFixed(6)} eV/√Ö</div>
                    <div>RMS Force: ${rmsFinalForce.toFixed(6)} eV/√Ö</div>
                    <div style="font-size: 14px; margin-top: 5px;">
                        Tolerance: ${data.relaxation_info?.fmax || 0.1} eV/√Ö
                    </div>
                `;
            } else {
                forcesEl.innerHTML = 'Force data not available';
            }
            
            // Stress Information
            if (data.final_prediction?.stress_GPa) {
                const stress = data.final_prediction.stress_GPa;
                const maxStress = Math.max(...stress.flat().map(Math.abs));
                const trace = stress[0][0] + stress[1][1] + stress[2][2];
                
                stressEl.innerHTML = `
                    <div>Max Stress: ${maxStress.toFixed(3)} GPa</div>
                    <div>Trace: ${trace.toFixed(3)} GPa</div>
                    <div style="font-size: 14px; margin-top: 5px;">
                        Hydrostatic: ${(trace/3).toFixed(3)} GPa
                    </div>
                `;
            } else {
                stressEl.innerHTML = 'Stress data not available';
            }
            
            // Settings
            settingsEl.innerHTML = `
                <div>Force Tolerance: ${data.relaxation_info?.fmax || 'N/A'} eV/√Ö</div>
                <div>Max Steps: ${data.relaxation_info?.max_steps || 'N/A'}</div>
                <div>Model: CHGNet v${data.model_info?.version || '0.3.0'}</div>
                <div>Device: ${data.model_info?.device || 'CPU'}</div>
            `;
        }

        function populateDataTab(data) {
            console.log('=== populateDataTab called ===');
            console.log('Data received:', data);
            
            const tableBody = document.getElementById('trajectoryTableBody');
            console.log('trajectoryTableBody element:', tableBody);
            
            tableBody.innerHTML = '';
            
            if (!data.trajectory_data?.energies?.length) {
                console.log('No trajectory data available');
                tableBody.innerHTML = '<tr><td colspan="4">Trajectory data not available</td></tr>';
                return;
            }
            
            console.log('Trajectory data found:', data.trajectory_data);
            
            const energies = data.trajectory_data.energies;
            const forceMagnitudes = data.trajectory_data.force_magnitudes;
            
            energies.forEach((energy, step) => {
                let maxForce = 'N/A';
                let rmsForce = 'N/A';
                
                if (forceMagnitudes && forceMagnitudes[step]) {
                    const stepForces = forceMagnitudes[step];
                    maxForce = Math.max(...stepForces).toFixed(6);
                    const rms = Math.sqrt(stepForces.reduce((sum, f) => sum + f*f, 0) / stepForces.length);
                    rmsForce = rms.toFixed(6);
                }
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${step + 1}</td>
                    <td>${energy.toFixed(6)}</td>
                    <td>${maxForce}</td>
                    <td>${rmsForce}</td>
                `;
                tableBody.appendChild(row);
            });
            
            // Populate Atomic Properties Table
            populateAtomicPropertiesTable(data);
            
            // Populate Stress Detail Table
            populateStressDetailTable(data);
        }
        
        function populateAtomicPropertiesTable(data) {
            console.log('=== populateAtomicPropertiesTable called ===');
            console.log('Data received:', data);
            
            const tableBody = document.getElementById('atomicPropertiesTableBody');
            console.log('atomicPropertiesTableBody element:', tableBody);
            
            tableBody.innerHTML = '';
            
            const finalPred = data.final_prediction;
            console.log('Final prediction data:', finalPred);
            
            if (!finalPred) {
                console.log('No final prediction data available');
                tableBody.innerHTML = '<tr><td colspan="7">Final prediction data not available</td></tr>';
                return;
            }
            
            // Get data arrays
            const forces = finalPred.forces_eV_per_A || [];
            const siteEnergies = finalPred.site_energies_eV || [];
            const magmoms = finalPred.magmoms_muB || [];
            
            console.log('Data arrays:');
            console.log('- forces:', forces);
            console.log('- siteEnergies:', siteEnergies);
            console.log('- magmoms:', magmoms);
            
            // Determine number of atoms
            const numAtoms = Math.max(forces.length, siteEnergies.length, magmoms.length);
            console.log('Number of atoms:', numAtoms);
            
            if (numAtoms === 0) {
                console.log('No atomic data available');
                tableBody.innerHTML = '<tr><td colspan="7">No atomic data available</td></tr>';
                return;
            }
            
            // Populate table rows
            for (let i = 0; i < numAtoms; i++) {
                const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Atom ${i+1}`;
                
                // Site Energy
                const siteEnergy = siteEnergies[i] !== undefined ? siteEnergies[i].toFixed(6) : '-';
                
                // Magnetic moment
                const magmom = magmoms[i] !== undefined ? magmoms[i].toFixed(3) : '-';
                
                // Forces
                let fx = '-', fy = '-', fz = '-', fMag = '-';
                if (forces[i]) {
                    fx = forces[i][0].toFixed(6);
                    fy = forces[i][1].toFixed(6);
                    fz = forces[i][2].toFixed(6);
                    const magnitude = Math.sqrt(forces[i][0]*forces[i][0] + forces[i][1]*forces[i][1] + forces[i][2]*forces[i][2]);
                    fMag = magnitude.toFixed(6);
                }
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${atomLabel}</td>
                    <td class="site-energy">${siteEnergy}</td>
                    <td class="magnetic-moment">${magmom}</td>
                    <td>${fx}</td>
                    <td>${fy}</td>
                    <td>${fz}</td>
                    <td>${fMag}</td>
                `;
                tableBody.appendChild(row);
            }
        }
        
        function populateStressDetailTable(data) {
            console.log('=== populateStressDetailTable called ===');
            console.log('Data received:', data);
            
            const tableBody = document.getElementById('stressDetailTableBody');
            console.log('stressDetailTableBody element:', tableBody);
            
            tableBody.innerHTML = '';
            
            if (!data.final_prediction?.stress_GPa) {
                console.log('No stress data available');
                tableBody.innerHTML = '<tr><td colspan="2">Stress data not available</td></tr>';
                return;
            }
            
            console.log('Stress data found:', data.final_prediction.stress_GPa);
            
            const stress = data.final_prediction.stress_GPa;
            const components = [
                ['œÉxx', stress[0][0]],
                ['œÉyy', stress[1][1]],
                ['œÉzz', stress[2][2]],
                ['œÉxy', stress[0][1]],
                ['œÉxz', stress[0][2]],
                ['œÉyz', stress[1][2]]
            ];
            
            components.forEach(([component, value]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${component}</td>
                    <td>${value.toFixed(6)}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        function drawCharts(data) {
            // Simple canvas-based charts (could be replaced with Chart.js for more advanced features)
            drawEnergyChart(data);
            drawForceChart(data);
        }

        function drawEnergyChart(data) {
            const canvas = document.getElementById('energyChart');
            const ctx = canvas.getContext('2d');
            const energies = data.trajectory_data?.energies || [];
            
            if (energies.length === 0) {
                ctx.fillText('No energy data available', 20, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Simple line chart with adjusted padding for Y-axis labels
            const leftPadding = 70;  // Increased for Y-axis labels and title
            const rightPadding = 20;
            const topPadding = 20;
            const bottomPadding = 50; // Increased for X-axis title
            const chartWidth = canvas.width - leftPadding - rightPadding;
            const chartHeight = canvas.height - topPadding - bottomPadding;
            
            const minEnergy = Math.min(...energies);
            const maxEnergy = Math.max(...energies);
            const energyRange = maxEnergy - minEnergy || 1;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftPadding, topPadding);
            ctx.lineTo(leftPadding, canvas.height - bottomPadding);
            ctx.lineTo(canvas.width - rightPadding, canvas.height - bottomPadding);
            ctx.stroke();
            
            // Draw axis labels and ticks
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis (Steps) labels
            const stepInterval = Math.max(1, Math.floor(energies.length / 5));
            for (let i = 0; i < energies.length; i += stepInterval) {
                const x = leftPadding + (i / (energies.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding + 15;
                
                // Draw tick mark
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - bottomPadding);
                ctx.lineTo(x, canvas.height - bottomPadding + 5);
                ctx.stroke();
                
                // Draw label
                ctx.fillText(i.toString(), x, y);
            }
            
            // Y-axis (Energy) labels
            ctx.textAlign = 'right';
            const energyInterval = energyRange / 4;
            for (let i = 0; i <= 4; i++) {
                const energy = minEnergy + (i * energyInterval);
                const y = canvas.height - bottomPadding - (i / 4) * chartHeight;
                const x = leftPadding - 10;
                
                // Draw tick mark
                ctx.beginPath();
                ctx.moveTo(leftPadding - 5, y);
                ctx.lineTo(leftPadding, y);
                ctx.stroke();
                
                // Draw label
                ctx.fillText(energy.toFixed(3), x, y + 4);
            }
            
            // Axis titles
            ctx.textAlign = 'center';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#333';
            
            // X-axis title
            ctx.fillText('Step', leftPadding + chartWidth / 2, canvas.height - 10);
            
            // Y-axis title (rotated)
            ctx.save();
            ctx.translate(20, topPadding + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Energy (eV/atom)', 0, 0);
            ctx.restore();
            
            // Draw energy line
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            energies.forEach((energy, step) => {
                const x = leftPadding + (step / (energies.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding - ((energy - minEnergy) / energyRange) * chartHeight;
                
                if (step === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw data points for key points (without overlapping text values)
            ctx.fillStyle = '#3498db';
            energies.forEach((energy, step) => {
                const x = leftPadding + (step / (energies.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding - ((energy - minEnergy) / energyRange) * chartHeight;
                
                // Draw points for first, last, and min/max points
                if (step === 0 || step === energies.length - 1 || energy === minEnergy || energy === maxEnergy) {
                    // Draw point only (no text values to avoid overlapping with axis labels)
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Update statistics
            updateEnergyStats(energies);
        }

        function drawForceChart(data) {
            const canvas = document.getElementById('forceChart');
            const ctx = canvas.getContext('2d');
            const forceMagnitudes = data.trajectory_data?.force_magnitudes || [];
            
            if (forceMagnitudes.length === 0) {
                ctx.fillText('No force data available', 20, canvas.height / 2);
                return;
            }
            
            // Calculate max forces per step
            const maxForces = forceMagnitudes.map(stepForces => Math.max(...stepForces));
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Simple line chart with adjusted padding for Y-axis labels
            const leftPadding = 70;  // Increased for Y-axis labels and title
            const rightPadding = 20;
            const topPadding = 20;
            const bottomPadding = 50; // Increased for X-axis title
            const chartWidth = canvas.width - leftPadding - rightPadding;
            const chartHeight = canvas.height - topPadding - bottomPadding;
            
            const minForce = Math.min(...maxForces);
            const maxForce = Math.max(...maxForces);
            const forceRange = maxForce - minForce || 1;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftPadding, topPadding);
            ctx.lineTo(leftPadding, canvas.height - bottomPadding);
            ctx.lineTo(canvas.width - rightPadding, canvas.height - bottomPadding);
            ctx.stroke();
            
            // Draw axis labels and ticks
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis (Steps) labels
            const stepInterval = Math.max(1, Math.floor(maxForces.length / 5));
            for (let i = 0; i < maxForces.length; i += stepInterval) {
                const x = leftPadding + (i / (maxForces.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding + 15;
                
                // Draw tick mark
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - bottomPadding);
                ctx.lineTo(x, canvas.height - bottomPadding + 5);
                ctx.stroke();
                
                // Draw label
                ctx.fillText(i.toString(), x, y);
            }
            
            // Y-axis (Force) labels
            ctx.textAlign = 'right';
            const forceInterval = forceRange / 4;
            for (let i = 0; i <= 4; i++) {
                const force = minForce + (i * forceInterval);
                const y = canvas.height - bottomPadding - (i / 4) * chartHeight;
                const x = leftPadding - 10;
                
                // Draw tick mark
                ctx.beginPath();
                ctx.moveTo(leftPadding - 5, y);
                ctx.lineTo(leftPadding, y);
                ctx.stroke();
                
                // Draw label
                ctx.fillText(force.toFixed(4), x, y + 4);
            }
            
            // Axis titles
            ctx.textAlign = 'center';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#333';
            
            // X-axis title
            ctx.fillText('Step', leftPadding + chartWidth / 2, canvas.height - 10);
            
            // Y-axis title (rotated)
            ctx.save();
            ctx.translate(20, topPadding + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Max Force (eV/√Ö)', 0, 0);
            ctx.restore();
            
            // Draw force line
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            maxForces.forEach((force, step) => {
                const x = leftPadding + (step / (maxForces.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding - ((force - minForce) / forceRange) * chartHeight;
                
                if (step === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw data points for key points (without overlapping text values)
            ctx.fillStyle = '#e74c3c';
            maxForces.forEach((force, step) => {
                const x = leftPadding + (step / (maxForces.length - 1)) * chartWidth;
                const y = canvas.height - bottomPadding - ((force - minForce) / forceRange) * chartHeight;
                
                // Draw points for first, last, and min/max points
                if (step === 0 || step === maxForces.length - 1 || force === minForce || force === maxForce) {
                    // Draw point only (no text values to avoid overlapping with axis labels)
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Update statistics
            updateForceStats(maxForces);
        }
        
        function updateEnergyStats(energies) {
            const statsContainer = document.getElementById('energy-chart-stats');
            if (!statsContainer) return;
            
            const minEnergy = Math.min(...energies);
            const maxEnergy = Math.max(...energies);
            const initialEnergy = energies[0];
            const finalEnergy = energies[energies.length - 1];
            const totalChange = finalEnergy - initialEnergy;
            
            statsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">Initial:</span>
                        <span class="stat-value">${initialEnergy.toFixed(6)} eV/atom</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Final:</span>
                        <span class="stat-value">${finalEnergy.toFixed(6)} eV/atom</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Min:</span>
                        <span class="stat-value">${minEnergy.toFixed(6)} eV/atom</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Max:</span>
                        <span class="stat-value">${maxEnergy.toFixed(6)} eV/atom</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Steps:</span>
                        <span class="stat-value">${energies.length}</span>
                    </div>
                </div>
            `;
        }
        
        function updateForceStats(maxForces) {
            const statsContainer = document.getElementById('force-chart-stats');
            if (!statsContainer) return;
            
            const minForce = Math.min(...maxForces);
            const maxForce = Math.max(...maxForces);
            const initialForce = maxForces[0];
            const finalForce = maxForces[maxForces.length - 1];
            const totalChange = finalForce - initialForce;
            
            statsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">Initial Max:</span>
                        <span class="stat-value">${initialForce.toFixed(4)} eV/√Ö</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Final Max:</span>
                        <span class="stat-value">${finalForce.toFixed(4)} eV/√Ö</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Peak:</span>
                        <span class="stat-value">${maxForce.toFixed(4)} eV/√Ö</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Minimum:</span>
                        <span class="stat-value">${minForce.toFixed(4)} eV/√Ö</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Steps:</span>
                        <span class="stat-value">${maxForces.length}</span>
                    </div>
                </div>
            `;
        }



    </script>

    <!-- Detailed Analysis Modal -->
    <div id="analysisModal" class="analysis-modal">
        <div class="analysis-modal-content">
            <div class="analysis-modal-header">
                <h2 class="modal-title">Detailed Analysis</h2>
                <button class="modal-close" onclick="closeAnalysisModal()">&times;</button>
            </div>
            
            <div class="tab-container">
                <button class="tab-button active" onclick="switchTab('energy')">Relaxation</button>
                <button class="tab-button" onclick="switchTab('data')">Data</button>
            </div>
            
            <div class="tab-content">
                <!-- Energy & Force Analysis Tab -->
                <div id="energy-tab" class="tab-pane active">
                    <div class="energy-analysis-container">
                        <h3>Relaxation Analysis</h3>
                        
                        <div class="relaxation-summary-section" style="margin-bottom: 20px;">
                            <div class="summary-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                                <div class="summary-card">
                                    <h4>Convergence Status</h4>
                                    <div id="summary-convergence">-</div>
                                </div>
                                <div class="summary-card">
                                    <h4>Energy Information</h4>
                                    <div id="summary-energy">-</div>
                                </div>
                                <div class="summary-card">
                                    <h4>Force Information</h4>
                                    <div id="summary-forces">-</div>
                                </div>
                                <div class="summary-card">
                                    <h4>Stress Information</h4>
                                    <div id="summary-stress">-</div>
                                </div>
                            </div>
                            
                            <div class="calculation-settings-section">
                                <h4>Calculation Settings</h4>
                                <div id="relaxation-settings" class="settings-display">-</div>
                            </div>
                        </div>
                        
                        <div class="energy-comparison-table">
                            <table class="analysis-table" id="energy-analysis-table">
                                <thead>
                                    <tr>
                                        <th>Property</th>
                                        <th>Initial Structure</th>
                                        <th>Final Structure</th>
                                    </tr>
                                </thead>
                                <tbody id="energy-analysis-body">
                                    <!-- Energy analysis data will be populated here -->
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="charts-container" style="margin-top: 30px;">
                            <div class="chart-section">
                                <h4>Energy Evolution</h4>
                                <div class="chart-with-stats">
                                    <canvas id="energyChart" width="400" height="200"></canvas>
                                    <div class="chart-stats" id="energy-chart-stats">
                                        <!-- Energy statistics will be populated here -->
                                    </div>
                                </div>
                            </div>
                            
                            <div class="chart-section" style="margin-top: 20px;">
                                <h4>Force Evolution</h4>
                                <div class="chart-with-stats">
                                    <canvas id="forceChart" width="400" height="200"></canvas>
                                    <div class="chart-stats" id="force-chart-stats">
                                        <!-- Force statistics will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="energy-insights" id="energy-insights">
                            <!-- Energy insights and interpretation will be populated here -->
                        </div>
                        
                        <div class="trajectory-data-section" style="margin-top: 30px;">
                            <h4>Step-by-Step Trajectory Data</h4>
                            <div style="overflow-x: auto;">
                                <table class="data-table" id="trajectoryTable">
                                    <thead>
                                        <tr>
                                            <th>Step</th>
                                            <th>Energy (eV/atom)</th>
                                            <th>Max Force (eV/√Ö)</th>
                                            <th>RMS Force (eV/√Ö)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="trajectoryTableBody">
                                        <!-- Data will be populated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <!-- Data Tab -->
                <div id="data-tab" class="tab-pane">
                    <h3>Final Atomic Properties</h3>
                    <div style="overflow-x: auto;">
                        <table class="data-table" id="atomicPropertiesTable">
                            <thead>
                                <tr>
                                    <th>Atom</th>
                                    <th>Site Energy (eV)</th>
                                    <th>Magnetic (ŒºB)</th>
                                    <th>Fx (eV/√Ö)</th>
                                    <th>Fy (eV/√Ö)</th>
                                    <th>Fz (eV/√Ö)</th>
                                    <th>|F| (eV/√Ö)</th>
                                </tr>
                            </thead>
                            <tbody id="atomicPropertiesTableBody">
                                <!-- Atomic properties data will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Stress Tensor</h3>
                    <div style="overflow-x: auto;">
                        <table class="data-table" id="stressDetailTable">
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th>Value (GPa)</th>
                                </tr>
                            </thead>
                            <tbody id="stressDetailTableBody">
                                <!-- Stress data will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Intelligent CIF filename generation
        function generateIntelligentCIFFilename() {
            let baseFilename = 'structure';
            let suffix = '';
            
            // Priority 1: Use current actual formula (most accurate)
            if (window.currentStructureData?.supercell_info?.formula) {
                baseFilename = window.currentStructureData.supercell_info.formula;
            }
            // Priority 2: If no formula available, use original filename
            else if (window.currentFilename) {
                baseFilename = window.currentFilename.replace(/\.cif$/i, '');
            }
            
            // Add operation history as suffix
            const operations = [];
            
            // Check for supercell operations
            if (window.currentStructureData?.supercell_info) {
                const nx = window.currentStructureData.supercell_info.nx || 1;
                const ny = window.currentStructureData.supercell_info.ny || 1; 
                const nz = window.currentStructureData.supercell_info.nz || 1;
                
                if (nx > 1 || ny > 1 || nz > 1) {
                    operations.push(`supercell_${nx}x${ny}x${nz}`);
                }
            }
            
            // Check for CHGNet optimization
            if (window.currentAnalysisData && window.currentAnalysisData.energy) {
                operations.push('chgnet_optimized');
            }
            
            // Check for element substitutions (compare with original formula)
            if (window.originalSupercellData?.supercell_info?.formula && 
                window.currentStructureData?.supercell_info?.formula &&
                window.originalSupercellData.supercell_info.formula !== window.currentStructureData.supercell_info.formula) {
                operations.push('substituted');
            }
            
            // Add operations as suffix
            if (operations.length > 0) {
                suffix = '_' + operations.join('_');
            }
            
            // Clean up formula for filename (remove special characters)
            baseFilename = baseFilename.replace(/[^a-zA-Z0-9-_]/g, '');
            
            // Add timestamp for uniqueness
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            
            return `${baseFilename}${suffix}_${timestamp}.cif`;
        }

        // Download Analysis Data Function
        async function downloadCurrentCIF() {
            try {
                // Check if structure data is available (use same logic as generateCIFFile)
                if (!window.currentFilename && !window.currentAnalysisData) {
                    alert('No structure data available. Please load a CIF file first.');
                    return;
                }

                console.log('Generating CIF file for current structure...');
                
                // Generate CIF content using existing function
                const cifContent = await generateCIFFile();
                
                if (!cifContent) {
                    alert('Failed to generate CIF file.');
                    return;
                }

                // Generate intelligent filename based on current structure state
                const filename = generateIntelligentCIFFilename();

                // Create and trigger download
                const blob = new Blob([cifContent], { type: 'text/plain;charset=utf-8' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                console.log(`CIF file downloaded: ${filename}`);
                
                // Show success notification
                showNotification(`CIF file downloaded: ${filename}`, 'success');

            } catch (error) {
                console.error('Error downloading CIF:', error);
                alert('Failed to download CIF file. Please try again.');
            }
        }

        async function downloadAnalysisData() {
            console.log('Download analysis data called');
            
            if (typeof JSZip === 'undefined') {
                console.error('JSZip not loaded');
                alert('JSZip„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ');
                return;
            }
            
            const zip = new JSZip();
            
            try {
                // 1. CIF file with P1 space group
                console.log('Generating CIF file...');
                const cifContent = await generateCIFFile();
                zip.file('structure_P1.cif', cifContent);
                
                // 2. Crystal Information CSV
                console.log('Generating Crystal Information CSV...');
                const crystalInfoCSV = generateCrystalInfoCSV();
                zip.file('crystal_information.csv', crystalInfoCSV);
                
                // 3. Energy and Magnetic text file
                console.log('Generating Energy and Magnetic text...');
                const energyMagneticText = generateEnergyMagneticText();
                zip.file('energy_magnetic.txt', energyMagneticText);
                
                // 4. Final Atomic Properties CSV
                console.log('Generating Final Atomic Properties CSV...');
                const atomicPropsCSV = generateFinalAtomicPropertiesCSV();
                zip.file('final_atomic_properties.csv', atomicPropsCSV);
                
                // 5. Stress Tensor CSV
                console.log('Generating Stress Tensor CSV...');
                const stressCSV = generateStressTensorCSV();
                zip.file('stress_tensor.csv', stressCSV);
                
                // 6. Step-by-Step Trajectory CSV
                console.log('Generating Step-by-Step Trajectory CSV...');
                const trajectoryCSV = generateTrajectoryCSV();
                zip.file('trajectory_data.csv', trajectoryCSV);
                
                // Generate and download ZIP file
                console.log('Generating ZIP file...');
                const content = await zip.generateAsync({type:'blob'});
                console.log('ZIP file generated, starting download...');
                
                // Generate descriptive filename
                const fileName = generateZipFileName();
                console.log('Generated ZIP filename:', fileName);
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log('Download completed');
                
            } catch (error) {
                console.error('Error generating ZIP file:', error);
                alert('ZIP„Éï„Ç°„Ç§„É´„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        }
        
        // Generate CIF file with P1 space group
        async function generateCIFFile() {
            console.log('=== GENERATING CIF FILE WITH P1 SPACE GROUP ===');
            console.log('Current filename:', window.currentFilename);
            console.log('Current analysis data:', window.currentAnalysisData);
            
            // Try to get the current CIF file from backend
            if (window.currentFilename) {
                try {
                    const url = `/api/generate-relaxed-structure-cif`;
                    console.log('Fetching CIF from URL:', url);
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            session_id: window.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
                        })
                    });
                    console.log('Response status:', response.status);
                    
                    if (response.ok) {
                        let cifContent = await response.text();
                        console.log('Original CIF content length:', cifContent.length);
                        console.log('Original CIF first 500 chars:', cifContent.substring(0, 500));
                        
                        // Modify to P1 space group
                        cifContent = cifContent.replace(
                            /_symmetry_space_group_name_H-M\s+.*/,
                            '_symmetry_space_group_name_H-M    P1'
                        );
                        cifContent = cifContent.replace(
                            /_space_group_IT_number\s+.*/,
                            '_space_group_IT_number           1'
                        );
                        
                        if (!cifContent.includes('_symmetry_space_group_name_H-M')) {
                            cifContent = cifContent.replace(
                                /data_\w+/,
                                '$&\n_symmetry_space_group_name_H-M    P1'
                            );
                        }
                        
                        if (!cifContent.includes('_space_group_IT_number')) {
                            cifContent = cifContent.replace(
                                /_symmetry_space_group_name_H-M\s+P1/,
                                '$&\n_space_group_IT_number           1'
                            );
                        }
                        
                        console.log('CIF modified to P1 space group');
                        console.log('Modified CIF first 500 chars:', cifContent.substring(0, 500));
                        return cifContent;
                    } else {
                        console.warn('Failed to fetch CIF, status:', response.status);
                    }
                } catch (error) {
                    console.error('Error fetching CIF from backend:', error);
                }
            }
            
            // Fallback: generate CIF using current analysis data
            console.log('Using fallback CIF generation with current analysis data');
            let cif = 'data_relaxed_structure_P1\n';
            cif += '_symmetry_space_group_name_H-M    P1\n';
            cif += '_space_group_IT_number           1\n\n';
            
            // Use direct data access instead of HTML parsing
            let latticeParams = null;
            if (window.currentStructureInfo?.lattice_parameters) {
                console.log('Using lattice parameters from currentStructureInfo');
                const lp = window.currentStructureInfo.lattice_parameters;
                latticeParams = {
                    a: lp.a,
                    b: lp.b,
                    c: lp.c,
                    alpha: lp.alpha,
                    beta: lp.beta,
                    gamma: lp.gamma
                };
            } else if (window.currentAnalysisData?.relaxed_structure_info?.lattice_parameters) {
                console.log('Using lattice parameters from analysis data');
                const lp = window.currentAnalysisData.relaxed_structure_info.lattice_parameters;
                latticeParams = {
                    a: lp.a,
                    b: lp.b,
                    c: lp.c,
                    alpha: lp.alpha,
                    beta: lp.beta,
                    gamma: lp.gamma
                };
            } else {
                console.log('Fallback: trying to extract from display');
                const crystalInfo = extractCrystalInfoFromDisplay();
                if (crystalInfo && crystalInfo.a) {
                    latticeParams = crystalInfo;
                }
            }
            
            console.log('Using lattice parameters:', latticeParams);
            
            if (latticeParams) {
                cif += `_cell_length_a    ${latticeParams.a.toFixed(6)}\n`;
                cif += `_cell_length_b    ${latticeParams.b.toFixed(6)}\n`;
                cif += `_cell_length_c    ${latticeParams.c.toFixed(6)}\n`;
                cif += `_cell_angle_alpha ${latticeParams.alpha.toFixed(6)}\n`;
                cif += `_cell_angle_beta  ${latticeParams.beta.toFixed(6)}\n`;
                cif += `_cell_angle_gamma ${latticeParams.gamma.toFixed(6)}\n\n`;
            } else {
                console.warn('No lattice parameters available, using defaults');
                cif += '_cell_length_a    1.000000\n';
                cif += '_cell_length_b    1.000000\n';
                cif += '_cell_length_c    1.000000\n';
                cif += '_cell_angle_alpha 90.000000\n';
                cif += '_cell_angle_beta  90.000000\n';
                cif += '_cell_angle_gamma 90.000000\n\n';
            }
            
            // Try to get atomic positions from analysis data
            cif += 'loop_\n';
            cif += '_atom_site_label\n';
            cif += '_atom_site_type_symbol\n';
            cif += '_atom_site_fract_x\n';
            cif += '_atom_site_fract_y\n';
            cif += '_atom_site_fract_z\n';
            cif += '_atom_site_occupancy\n\n';
            
            // Try to get positions from analysis data
            if (window.currentAnalysisData?.final_positions && window.currentAnalysisData?.elements) {
                console.log('Using atomic positions from analysis data');
                const positions = window.currentAnalysisData.final_positions;
                const elements = window.currentAnalysisData.elements;
                
                for (let i = 0; i < positions.length; i++) {
                    const element = elements[i] || 'X';
                    const pos = positions[i];
                    cif += `${element}${i+1} ${element} ${pos[0].toFixed(6)} ${pos[1].toFixed(6)} ${pos[2].toFixed(6)} 1.000\n`;
                }
            } else {
                console.warn('No atomic positions available, using placeholder');
                cif += 'X1 X 0.000000 0.000000 0.000000 1.000\n';
            }
            
            console.log('Generated CIF content:', cif);
            return cif;
        }
        
        // Generate Crystal Information CSV
        function generateCrystalInfoCSV() {
            console.log('=== GENERATING CRYSTAL INFORMATION CSV ===');
            console.log('Available data sources:');
            console.log('- window.currentStructureInfo:', window.currentStructureInfo);
            console.log('- window.currentAnalysisData:', window.currentAnalysisData);
            
            let csv = 'Property,Value\n';
            csv += 'Space Group,P1\n';
            csv += 'Space Group Number,1\n';
            
            // Use direct data access instead of HTML parsing
            let structureInfo = null;
            if (window.currentStructureInfo) {
                structureInfo = window.currentStructureInfo;
                console.log('Using currentStructureInfo');
            } else if (window.currentAnalysisData?.relaxed_structure_info) {
                structureInfo = window.currentAnalysisData.relaxed_structure_info;
                console.log('Using currentAnalysisData.relaxed_structure_info');
            }
            
            console.log('Structure info being used:', structureInfo);
            
            if (structureInfo) {
                // Direct data access - no regex parsing needed
                if (structureInfo.formula) csv += `Formula,${structureInfo.formula}\n`;
                if (structureInfo.lattice_parameters) {
                    const lp = structureInfo.lattice_parameters;
                    csv += `a (√Ö),${lp.a.toFixed(5)}\n`;
                    csv += `b (√Ö),${lp.b.toFixed(5)}\n`;
                    csv += `c (√Ö),${lp.c.toFixed(5)}\n`;
                    csv += `Œ± (¬∞),${lp.alpha.toFixed(5)}\n`;
                    csv += `Œ≤ (¬∞),${lp.beta.toFixed(5)}\n`;
                    csv += `Œ≥ (¬∞),${lp.gamma.toFixed(5)}\n`;
                }
                if (structureInfo.volume) csv += `Volume (√Ö¬≥),${structureInfo.volume.toFixed(5)}\n`;
                if (structureInfo.density) csv += `Density (g/cm¬≥),${structureInfo.density.toFixed(4)}\n`;
                if (structureInfo.num_sites) csv += `Total atoms,${structureInfo.num_sites}\n`;
            } else {
                console.warn('No structure info available, falling back to HTML extraction');
                // Fallback to HTML extraction only if direct data is not available
                const crystalInfo = extractCrystalInfoFromDisplay();
                if (crystalInfo) {
                    if (crystalInfo.formula) csv += `Formula,${crystalInfo.formula}\n`;
                    if (crystalInfo.a) csv += `a (√Ö),${crystalInfo.a}\n`;
                    if (crystalInfo.b) csv += `b (√Ö),${crystalInfo.b}\n`;
                    if (crystalInfo.c) csv += `c (√Ö),${crystalInfo.c}\n`;
                    if (crystalInfo.alpha) csv += `Œ± (¬∞),${crystalInfo.alpha}\n`;
                    if (crystalInfo.beta) csv += `Œ≤ (¬∞),${crystalInfo.beta}\n`;
                    if (crystalInfo.gamma) csv += `Œ≥ (¬∞),${crystalInfo.gamma}\n`;
                    if (crystalInfo.volume) csv += `Volume (√Ö¬≥),${crystalInfo.volume}\n`;
                    if (crystalInfo.density) csv += `Density (g/cm¬≥),${crystalInfo.density}\n`;
                } else {
                    csv += 'Formula,Unknown\n';
                    csv += 'a (√Ö),N/A\n';
                    csv += 'b (√Ö),N/A\n';
                    csv += 'c (√Ö),N/A\n';
                    csv += 'Œ± (¬∞),N/A\n';
                    csv += 'Œ≤ (¬∞),N/A\n';
                    csv += 'Œ≥ (¬∞),N/A\n';
                    csv += 'Volume (√Ö¬≥),N/A\n';
                    csv += 'Density (g/cm¬≥),N/A\n';
                }
            }
            
            console.log('Generated Crystal Information CSV:', csv);
            return csv;
        }
        
        // Generate Energy and Magnetic text file
        function generateEnergyMagneticText() {
            console.log('=== GENERATING ENERGY AND MAGNETIC TEXT ===');
            console.log('Available data sources:');
            console.log('- window.currentAnalysisData:', window.currentAnalysisData);
            console.log('- window.currentStructureInfo:', window.currentStructureInfo);
            
            let text = 'Energy and Magnetic Properties\n';
            text += '================================\n\n';
            
            // Use direct data access instead of HTML parsing
            let energyData = null;
            let magneticData = null;
            let numAtoms = 0;
            
            if (window.currentAnalysisData) {
                const analysisData = window.currentAnalysisData;
                console.log('Using analysis data for energy/magnetic calculation');
                
                // Get number of atoms
                if (window.currentStructureInfo?.num_sites) {
                    numAtoms = window.currentStructureInfo.num_sites;
                } else if (analysisData.elements) {
                    numAtoms = analysisData.elements.length;
                } else if (analysisData.final_prediction?.magmoms_muB) {
                    numAtoms = analysisData.final_prediction.magmoms_muB.length;
                }
                
                console.log('Number of atoms:', numAtoms);
                
                // Extract energy data from direct calculation
                if (analysisData.final_prediction?.energy_eV_per_atom !== undefined) {
                    const energyPerAtom = analysisData.final_prediction.energy_eV_per_atom;
                    const totalEnergy = analysisData.final_prediction.total_energy_eV !== undefined ? analysisData.final_prediction.total_energy_eV : energyPerAtom * numAtoms;
                    
                    energyData = {
                        total: totalEnergy,
                        perAtom: energyPerAtom,
                        numAtoms: numAtoms
                    };
                    console.log('Calculated energy data:', energyData);
                }
                
                // Extract magnetic data from direct calculation
                if (analysisData.final_prediction?.magmoms_muB) {
                    const magmoms = analysisData.final_prediction.magmoms_muB;
                    
                    // Calculate total magnetic moment using the same method as display
                    // Note: Using absolute values as per the current display logic
                    const totalMagmomAbs = magmoms.reduce((sum, mag) => sum + Math.abs(mag), 0);
                    // Also calculate net magnetic moment (vector sum)
                    const netMagmom = magmoms.reduce((sum, mag) => sum + mag, 0);
                    
                    magneticData = {
                        total: totalMagmomAbs,  // Match display calculation
                        net: netMagmom,         // Physical net moment
                        individual: magmoms
                    };
                    console.log('Calculated magnetic data:', magneticData);
                    console.log('- Total |magnetic moment|:', totalMagmomAbs);
                    console.log('- Net magnetic moment:', netMagmom);
                }
            }
            
            // If direct data is not available, fall back to HTML extraction
            if (!energyData || !magneticData) {
                console.warn('Direct data not available, falling back to HTML extraction');
                if (!energyData) {
                    energyData = extractEnergyFromDisplay();
                }
                if (!magneticData) {
                    magneticData = extractMagneticFromDisplay();
                }
            }
            
            // Generate text output
            if (energyData) {
                text += 'Energy Information:\n';
                text += `Total Energy: ${energyData.total.toFixed(6)} eV\n`;
                text += `Energy per atom: ${energyData.perAtom.toFixed(6)} eV/atom\n`;
                text += `Number of atoms: ${energyData.numAtoms}\n\n`;
            } else {
                text += 'Energy Information: Not available\n\n';
            }
            
            if (magneticData) {
                text += 'Magnetic Information:\n';
                text += `Total |magnetic moment|: ${magneticData.total.toFixed(6)} ŒºB\n`;
                
                // Include net magnetic moment if available
                if (magneticData.net !== undefined) {
                    text += `Net magnetic moment: ${magneticData.net.toFixed(6)} ŒºB\n`;
                }
                
                // Include individual magnetic moments if available
                if (magneticData.individual && magneticData.individual.length > 0) {
                    text += '\nIndividual atomic magnetic moments:\n';
                    magneticData.individual.forEach((mag, i) => {
                        // Try to get element names if available
                        let atomLabel = `Atom ${i+1}`;
                        if (window.currentAnalysisData?.elements && window.currentAnalysisData.elements[i]) {
                            atomLabel = `${window.currentAnalysisData.elements[i]}${i+1}`;
                        }
                        text += `${atomLabel}: ${mag.toFixed(6)} ŒºB\n`;
                    });
                }
                text += '\n';
            } else {
                text += 'Magnetic Information: Not available\n\n';
            }
            
            // Add calculation details
            text += 'Calculation Details:\n';
            text += '===================\n';
            if (window.currentAnalysisData?.relaxation_converged !== undefined) {
                text += `Relaxation converged: ${window.currentAnalysisData.relaxation_converged}\n`;
            }
            if (window.currentAnalysisData?.relaxation_steps !== undefined) {
                text += `Relaxation steps: ${window.currentAnalysisData.relaxation_steps}\n`;
            }
            if (window.currentAnalysisData?.fmax !== undefined) {
                text += `Force tolerance (fmax): ${window.currentAnalysisData.fmax} eV/√Ö\n`;
            }
            text += 'Model: CHGNet\n';
            
            console.log('Generated Energy and Magnetic text:', text);
            return text;
        }
        
        // Helper function to extract crystal info from display
        function extractCrystalInfoFromDisplay() {
            console.log('=== EXTRACTING CRYSTAL INFO FROM DISPLAY ===');
            
            // Try both main crystal info and modal
            const sources = [
                document.getElementById('main-crystal-info'),
                document.getElementById('infoContent')
            ];
            
            for (const source of sources) {
                if (source && source.innerHTML.trim()) {
                    const html = source.innerHTML;
                    console.log(`Found crystal info in ${source.id}:`);
                    console.log('Raw HTML:', html);
                    
                    const info = {};
                    
                    // Extract various crystal parameters with more precise regex patterns
                    const formulaMatch = html.match(/<strong>Formula:<\/strong>\s*([^<]+)/i);
                    const aMatch = html.match(/a\s*=\s*([\d.]+)\s*√Ö/i);
                    const bMatch = html.match(/b\s*=\s*([\d.]+)\s*√Ö/i);
                    const cMatch = html.match(/c\s*=\s*([\d.]+)\s*√Ö/i);
                    const alphaMatch = html.match(/Œ±\s*=\s*([\d.]+)¬∞/i);
                    const betaMatch = html.match(/Œ≤\s*=\s*([\d.]+)¬∞/i);
                    const gammaMatch = html.match(/Œ≥\s*=\s*([\d.]+)¬∞/i);
                    const volumeMatch = html.match(/Volume\s*=\s*([\d.]+)\s*≈≤/i);
                    const densityMatch = html.match(/<strong>Density:<\/strong>\s*([\d.]+)\s*g\/cm¬≥/i);
                    
                    console.log('Regex extraction results:', {
                        formulaMatch, aMatch, bMatch, cMatch, alphaMatch, betaMatch, gammaMatch, volumeMatch, densityMatch
                    });
                    
                    if (formulaMatch) info.formula = formulaMatch[1].trim();
                    if (aMatch) info.a = parseFloat(aMatch[1]);
                    if (bMatch) info.b = parseFloat(bMatch[1]);
                    if (cMatch) info.c = parseFloat(cMatch[1]);
                    if (alphaMatch) info.alpha = parseFloat(alphaMatch[1]);
                    if (betaMatch) info.beta = parseFloat(betaMatch[1]);
                    if (gammaMatch) info.gamma = parseFloat(gammaMatch[1]);
                    if (volumeMatch) info.volume = parseFloat(volumeMatch[1]);
                    if (densityMatch) info.density = parseFloat(densityMatch[1]);
                    
                    console.log('Final extracted crystal info:', info);
                    
                    if (Object.keys(info).length > 0) {
                        return info;
                    }
                }
            }
            
            console.log('No crystal info found in display');
            return null;
        }
        
        // Helper function to extract energy from display
        function extractEnergyFromDisplay() {
            console.log('Extracting energy from display');
            
            const energySummary = document.getElementById('energy-summary');
            if (energySummary) {
                const text = energySummary.textContent;
                console.log('Energy summary text:', text);
                
                // Pattern: "‚ö° Energy: -42.07 eV (-8.415 eV/atom, 5 atoms)"
                const totalMatch = text.match(/Energy:\s*([-\d.]+)\s*eV/);
                const perAtomMatch = text.match(/\(([-\d.]+)\s*eV\/atom/);
                const atomsMatch = text.match(/(\d+)\s*atoms/);
                
                if (totalMatch || perAtomMatch) {
                    const result = {
                        total: totalMatch ? parseFloat(totalMatch[1]) : null,
                        perAtom: perAtomMatch ? parseFloat(perAtomMatch[1]) : null,
                        numAtoms: atomsMatch ? parseInt(atomsMatch[1]) : null
                    };
                    console.log('Extracted energy data:', result);
                    return result;
                }
            }
            
            console.log('No energy data found in display');
            return null;
        }
        
        // Helper function to extract magnetic from display
        function extractMagneticFromDisplay() {
            console.log('Extracting magnetic from display');
            
            const magneticSummary = document.getElementById('magnetic-summary');
            if (magneticSummary) {
                const text = magneticSummary.textContent;
                console.log('Magnetic summary text:', text);
                
                // Pattern: "üß≤ Magnetic: 0.102 ¬µB total"
                const totalMatch = text.match(/Magnetic:\s*([-\d.]+)\s*¬µB\s*total/);
                
                if (totalMatch) {
                    const result = {
                        total: parseFloat(totalMatch[1])
                    };
                    console.log('Extracted magnetic data:', result);
                    return result;
                }
            }
            
            console.log('No magnetic data found in display');
            return null;
        }
        
        // Generate Final Atomic Properties CSV
        function generateFinalAtomicPropertiesCSV() {
            console.log('=== GENERATING FINAL ATOMIC PROPERTIES CSV ===');
            console.log('Using same logic as populateAtomicPropertiesTable');
            
            let csv = 'Atom,Site Energy (eV),Magnetic (ŒºB),Fx (eV/√Ö),Fy (eV/√Ö),Fz (eV/√Ö),|F| (eV/√Ö)\n';
            
            if (!window.currentAnalysisData?.final_prediction) {
                console.warn('No final prediction data available');
                csv += 'No data available,-,-,-,-,-,-\n';
                return csv;
            }
            
            const finalPred = window.currentAnalysisData.final_prediction;
            console.log('Final prediction data:', finalPred);
            
            // Get data arrays (same as populateAtomicPropertiesTable)
            const forces = finalPred.forces_eV_per_A || [];
            const siteEnergies = finalPred.site_energies_eV || [];
            const magmoms = finalPred.magmoms_muB || [];
            
            console.log('Data arrays:');
            console.log('- forces:', forces);
            console.log('- siteEnergies:', siteEnergies);
            console.log('- magmoms:', magmoms);
            
            // Determine number of atoms (same logic as display)
            const numAtoms = Math.max(forces.length, siteEnergies.length, magmoms.length);
            console.log('Number of atoms:', numAtoms);
            
            if (numAtoms === 0) {
                console.warn('No atomic data available');
                csv += 'No data available,-,-,-,-,-,-\n';
                return csv;
            }
            
            // Populate CSV rows (same logic as display)
            for (let i = 0; i < numAtoms; i++) {
                // Atom label (same as display logic)
                const atomLabel = window.currentLabels && window.currentLabels[i] ? window.currentLabels[i] : `Atom ${i+1}`;
                
                // Site Energy (same precision as display)
                const siteEnergy = siteEnergies[i] !== undefined ? siteEnergies[i].toFixed(6) : '-';
                
                // Magnetic moment (same precision as display)
                const magmom = magmoms[i] !== undefined ? magmoms[i].toFixed(3) : '-';
                
                // Forces (same calculation as display)
                let fx = '-', fy = '-', fz = '-', fMag = '-';
                if (forces[i]) {
                    fx = forces[i][0].toFixed(6);
                    fy = forces[i][1].toFixed(6);
                    fz = forces[i][2].toFixed(6);
                    const magnitude = Math.sqrt(forces[i][0]*forces[i][0] + forces[i][1]*forces[i][1] + forces[i][2]*forces[i][2]);
                    fMag = magnitude.toFixed(6);
                }
                
                csv += `${atomLabel},${siteEnergy},${magmom},${fx},${fy},${fz},${fMag}\n`;
            }
            
            console.log('Generated Final Atomic Properties CSV:', csv);
            return csv;
        }
        
        // Generate Stress Tensor CSV
        function generateStressTensorCSV() {
            console.log('=== GENERATING STRESS TENSOR CSV ===');
            console.log('Using same logic as populateStressDetailTable');
            
            let csv = 'Component,Value (GPa)\n';
            
            if (!window.currentAnalysisData?.final_prediction?.stress_GPa) {
                console.warn('No stress data available');
                csv += 'No data available,-\n';
                return csv;
            }
            
            const stress = window.currentAnalysisData.final_prediction.stress_GPa;
            console.log('Stress data found:', stress);
            
            // Define components (same as display logic)
            const components = [
                ['œÉxx', stress[0][0]],
                ['œÉyy', stress[1][1]],
                ['œÉzz', stress[2][2]],
                ['œÉxy', stress[0][1]],
                ['œÉxz', stress[0][2]],
                ['œÉyz', stress[1][2]]
            ];
            
            // Add each component to CSV (same precision as display)
            components.forEach(([component, value]) => {
                csv += `${component},${value.toFixed(6)}\n`;
            });
            
            console.log('Generated Stress Tensor CSV:', csv);
            return csv;
        }
        
        // Generate Step-by-Step Trajectory CSV
        function generateTrajectoryCSV() {
            console.log('=== GENERATING STEP-BY-STEP TRAJECTORY CSV ===');
            console.log('Using same logic as trajectory data display');
            
            let csv = 'Step,Energy (eV),Max Force (eV/√Ö),RMS Force (eV/√Ö)\n';
            
            if (!window.currentAnalysisData?.trajectory_data?.energies?.length) {
                console.warn('No trajectory data available');
                csv += 'No data available,-,-,-\n';
                return csv;
            }
            
            console.log('Trajectory data found:', window.currentAnalysisData.trajectory_data);
            
            const energies = window.currentAnalysisData.trajectory_data.energies;
            const forceMagnitudes = window.currentAnalysisData.trajectory_data.force_magnitudes;
            
            // Process each step (same logic as display)
            energies.forEach((energy, step) => {
                let maxForce = 'N/A';
                let rmsForce = 'N/A';
                
                if (forceMagnitudes && forceMagnitudes[step]) {
                    const stepForces = forceMagnitudes[step];
                    // Max Force calculation (same as display)
                    maxForce = Math.max(...stepForces).toFixed(6);
                    // RMS Force calculation (same as display)
                    const rms = Math.sqrt(stepForces.reduce((sum, f) => sum + f*f, 0) / stepForces.length);
                    rmsForce = rms.toFixed(6);
                }
                
                // Add to CSV (same format as display: step+1, energy.toFixed(6))
                csv += `${step + 1},${energy.toFixed(6)},${maxForce},${rmsForce}\n`;
            });
            
            console.log('Generated Step-by-Step Trajectory CSV:', csv);
            return csv;
        }
        
        // Generate descriptive ZIP filename
        function generateZipFileName() {
            console.log('=== GENERATING ZIP FILENAME ===');
            
            // Get formula and remove spaces
            let formula = 'Unknown';
            if (window.currentStructureInfo?.formula) {
                formula = window.currentStructureInfo.formula.replace(/\s+/g, '');
            } else if (window.currentAnalysisData?.relaxed_structure_info?.formula) {
                formula = window.currentAnalysisData.relaxed_structure_info.formula.replace(/\s+/g, '');
            }
            
            // Get number of atoms
            let numAtoms = '';
            if (window.currentStructureInfo?.num_sites) {
                numAtoms = `${window.currentStructureInfo.num_sites}atoms`;
            } else if (window.currentAnalysisData?.elements) {
                numAtoms = `${window.currentAnalysisData.elements.length}atoms`;
            }
            
            // Generate timestamp
            const now = new Date();
            const timestamp = now.getFullYear().toString() +
                            (now.getMonth() + 1).toString().padStart(2, '0') +
                            now.getDate().toString().padStart(2, '0') + '_' +
                            now.getHours().toString().padStart(2, '0') +
                            now.getMinutes().toString().padStart(2, '0') +
                            now.getSeconds().toString().padStart(2, '0');
            
            // Construct filename
            let fileName = 'CrystalNexus';
            if (formula !== 'Unknown') {
                fileName += `_${formula}`;
            }
            if (numAtoms) {
                fileName += `_${numAtoms}`;
            }
            fileName += `_${timestamp}.zip`;
            
            console.log('Generated filename components:', {formula, numAtoms, timestamp, fileName});
            return fileName;
        }
    </script>

    <!-- CHGNet Information Modal -->
    <div id="chgnetInfoModal" class="chgnet-info-modal">
        <div class="chgnet-info-content">
            <span class="chgnet-info-close" onclick="closeCHGNetInfo()">&times;</span>
            <h2>CHGNet: Charge-informed Graph Neural Network</h2>
            
            <div class="chgnet-section">
                <h4>1. Scientific Foundation</h4>
                <p>CHGNet (Crystal Hamiltonian Graph Neural Network) is a pretrained universal neural network potential for charge-informed atomistic modeling, developed by Deng et al. (2023). This method represents a significant advancement in machine learning interatomic potentials by incorporating both structural and electronic degrees of freedom through explicit modeling of atomic partial charges and magnetic moments.</p>
            </div>

            <div class="chgnet-section">
                <h4>2. Methodology</h4>
                <p><strong>Graph Neural Network Architecture:</strong> Crystal structures are represented as undirected graphs G = (V, E), with vertices V corresponding to atoms and edges E representing interatomic interactions. The model utilizes a message-passing framework with a distance cutoff radius of 5.0 √Ö to capture local chemical environments.</p>
                
                <p><strong>Multi-task Learning Framework:</strong> CHGNet implements a multi-task learning approach, simultaneously predicting multiple target properties (energy, forces, stress, magnetic moments) through shared representations. The total loss function incorporates task-specific weighting coefficients optimized during training.</p>
                
                <p><strong>Universal Potential:</strong> The model covers 89 elements from hydrogen to actinium, trained with approximately 400,000 trainable parameters optimized for computational efficiency while maintaining chemical accuracy.</p>
            </div>

            <div class="chgnet-section">
                <h4>3. Training Dataset</h4>
                <p>The model is trained on 1,580,395 crystal structures from the Materials Project database, encompassing:</p>
                <ul>
                    <li>Comprehensive elemental coverage (89 elements: H-Ac)</li>
                    <li>Diverse crystal systems and space groups with representative sampling</li>
                    <li>Multiple property targets: energies, forces, stresses, and magnetic moments</li>
                    <li>Materials spanning metallic, semiconducting, and insulating electronic structures</li>
                </ul>
            </div>

            <div class="chgnet-section">
                <h4>4. Performance Characteristics</h4>
                
                <p><strong>Energetic Properties:</strong> Energy predictions achieve mean absolute errors of 29.8 meV/atom relative to DFT calculations, enabling reliable thermodynamic analysis and materials screening applications.</p>
                
                <p><strong>Mechanical Properties:</strong> Atomic force predictions demonstrate mean absolute errors of 0.076 eV/√Ö, suitable for structural relaxation and molecular dynamics simulations with high fidelity.</p>
                
                <p><strong>Electronic Properties:</strong> The model provides predictions of site-resolved magnetic moments and partial atomic charges, facilitating electronic structure analysis beyond conventional interatomic potentials.</p>
                
                <p><strong>Computational Efficiency:</strong> CHGNet achieves significant acceleration compared to DFT while maintaining near-quantum accuracy, with linear scaling behavior suitable for large supercell calculations.</p>
            </div>

            <div class="chgnet-section">
                <h4>5. Applications and Limitations</h4>
                <p>CHGNet enables rapid screening of materials properties, high-throughput computational materials discovery, and large-scale atomistic simulations previously computationally prohibitive with ab initio methods. The model demonstrates excellent transferability across diverse chemical compositions and crystal structures within the training data domain.</p>
                
                <p><strong>Model Limitations:</strong> CHGNet predictions are most reliable within the chemical and structural space of the training data. Recent research has identified systematic errors including energy and force underprediction, tendency to overestimate lattice constants, and underestimate densities due to sampling bias toward near-equilibrium configurations in the training dataset.</p>
            </div>

            <div class="chgnet-section">
                <h4>Reference</h4>
                <div class="citation-box">
                    <p>Deng, B., Zhong, P., Jun, K. <em>et al.</em> CHGNet as a pretrained universal neural network potential for charge-informed atomistic modelling. <em>Nat. Mach. Intell.</em> <strong>5</strong>, 1031‚Äì1041 (2023).</p>
                    <p>DOI: <a href="https://doi.org/10.1038/s42256-023-00716-3" target="_blank" style="color: #2980b9;">10.1038/s42256-023-00716-3</a></p>
                </div>
            </div>

            <div class="chgnet-links">
                <h4>External Resources</h4>
                <a href="https://www.nature.com/articles/s42256-023-00716-3" target="_blank">Nature Machine Intelligence Paper</a>
                <a href="https://github.com/CederGroupHub/chgnet" target="_blank">GitHub Repository</a>
                <a href="https://materialsproject.org/" target="_blank">Materials Project Database</a>
                <a href="https://chgnet.lbl.gov/" target="_blank">Official Documentation</a>
            </div>
        </div>
    </div>

    <script>
        function showCHGNetInfo() {
            document.getElementById('chgnetInfoModal').style.display = 'block';
        }

        function closeCHGNetInfo() {
            document.getElementById('chgnetInfoModal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            var modal = document.getElementById('chgnetInfoModal');
            if (event.target == modal) {
                closeCHGNetInfo();
            }
        }
    </script>

</body>
</html>